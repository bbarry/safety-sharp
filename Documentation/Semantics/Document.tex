% requires cm-super
% use MikTex package manager to install (might require database synchronization)
% run initexmf --mkmaps to update miktex mapfiles

\documentclass[a4paper,10pt,english]{article}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[T1,hyphens]{url}
\usepackage[pdftex]{hyperref}
\usepackage{mathrsfs}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage[fleqn,leqno]{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{xspace}
\usepackage{listings}
\usepackage{cleveref}
\hypersetup{colorlinks=false, 
				linkcolor=black,
				citecolor=black,
				pdfauthor={Axel Habermaier, Johannes Leupolz},
				pdftitle={SafetySharp},
				pdfborder={0 0 0}, 
				pdfpagelayout=SinglePage,
				pdfsubject=SafetySharp}

\input{Macros}

\title{SafetySharp Semantics}
\author{Axel Habermaier, Johannes Leupolz}

\begin{document}

\maketitle

\section{Conventions}
Throughout the remainder of this report, we use the following conventions in all formal definitions wherever appropriate:

\header{Optional Elements and Failure Elements}
	We use $\missing$ and $\failure$ to denote the missing element and the failure element respectively. For some domain $A$, it is
	always true that $\missing \notin A$ and $\failure \notin A$. We define the liftings $\liftMissing{A} := A \cup
	\missing$, $\liftFailure{A} := A \cup \failure$, and $\liftMissingFailure{A} := A \cup \varepsilon \cup	\bot$.
	For some $a \in A$, we know that $a \neq \missing$ and $a \neq \failure$, whereas for $\liftMissing{a} \in
	\liftMissing{A}$, we only know that $\liftMissing{a} \neq \failure$, but $\liftMissing{a}$ might be $\missing$ or
	any element of $A$. When we write $a \in \liftMissing{A}$ or $a = f(a')$ for some function $f \colon A \rightarrow
	\liftMissing{A}$, $a$ cannot be $\missing$, so the selection or assignment is only possible if the selected or
	returned value is not $\missing$. For example, this allows us to shorten some side conditions in function definitions with case
	distinctions. The following two definitions of function $g \colon A \rightarrow \liftFailure{A}$ illustrate the usage of this
	convention.
	With function $f$ defined as above, the following two definitions of $g$ are equivalent:
	\begin{align*}
		g(a') = \begin{cases}
			a & \text{if } \quad a = f(a') \\
			\bot & \text{if } \quad \missing = f(a')
		\end{cases}
		&&&
		g(a') = \begin{cases}
			\liftMissing{a} & \text{if } \quad \liftMissing{a} = f(a') \wedge \liftMissing{a} \neq \missing	\\
			\bot & \text{if } \quad \missing = f(a')
		\end{cases}
	\end{align*}

\header{Functions}
	Oftentimes, the codomain of some function includes the failure element. Usually the definitions of those functions contain case distinctions.
	Whenever we do not specify all cases for such a function, the remaining cases are implicitly assumed to return $\failure$.
	Alternatively, we use the word ``otherwise'' to denote a side condition that is true if the side conditions of all other cases are not true. We do not use partial functions.

	It is sometimes necessary to change the value a function returns for a specific input. We establish the notation $f[a \mapsto b]$
	for some function $f \colon A \rightarrow B$ that serves this purpose and is defined as follows:
	\begin{equation*}
	f[a \mapsto b](a') = \begin{cases}
		b & \text{if } \quad a' = a \\
		f(a') & \text{otherwise}
	\end{cases}
	\end{equation*}

	For convenience, we use the following notations to update several values at the same time: 
	$f[a_1 \; a_2 \mapsto b] = f[a_1 \mapsto b][a_2 \mapsto b]$, $f[a_1 \; a_2 \mapsto b_1 \; b_2] = f[a_1 \mapsto b_1][a_2 \mapsto b_2]$, and $\_$ represents all
	input values, such that $f[ \_ \mapsto b](a)$ returns $b$ for all input values $a$.	This is only well-defined if all updated input values are
	mutually distinct.

\header{Metavariables}
	Words starting with a capital letter denote a semantic domain. For instance, the set of two-dimensional vectors might be defined as 
	$\mathit{Vector2} = \mathbb{R} \times \mathbb{R}$. To denote a single element of a domain, we use metavariables that are identical to the domain's
	name starting with a lower-case letter; in this example, $\mathit{vector2}$. 
	The default metavariable for a domain can be overridden by explicitly specifying the metavariable 
	when defining the domain, such as $v \in \mathit{Vector2} = \mathbb{R} \times \mathbb{R}$. In this case, $v$ denotes an element of domain $\mathit{Vector2}$.
	We also use metavariables in variously decorated forms such as $v'$, $v''$, $v_0$, $v_1$, and so on. 
	We adorn a domain's metavariable with an arrow at the top to denote a list of elements of the domain, for example
	$\toList{v} \in \ToList{\mathit{Vector2}}$.
 
\header{Handling of Tuples}
	Most of the semantic domains we deal with in the following chapters consist of several subdomains. 
	Let $X = A \times B \times C \times D \times \ToList{E}$ be a domain and $x \in X$ be
	an element of that domain. To get the projection of $x$ to one of its subdomains, we subscript $x$ with the metavariable of the
	domain we want to project to. For instance, to get $x$'s projection to domain $D$, we write $x_d$. We use the same convention if the projected subdomain is
	a list, so $x_{\toList{e}}$ projects $x$ to the element in $\ToList{E}$.
	
	We often have a complex tuple type instance like $(a, b, c, d, \toList{e}) \in X$, but in a rule or
	function we actually only need a few of the variables. For example, suppose we only need to use $c$ and $\toList{e}$ in a rule. In that case,
	we write $x \triangleright c, \toList{e}$.
	This way, we can reference the entire tuple with $x$ and do not need any projections to access $x$'s subdomains. When using this projection syntax, we list the
	metavariables of the subdomains in the order they were specified in the definition of $X$. If this notational convention causes any ambiguities, we either
	resort to the standard tuple notation or list all subdomains in our projection notation. We use a notation similar to the
	projection syntax to update only some of a tuple's values: If $x \triangleright a, b, c, d, \toList{e}$, we write $x' = x
	\triangleleft a', \toList{e'}$ as an alternative to $x' = (a', b, c, d, \toList{e'})$.  

\section{Formal Intermediate Language}
The Formal Intermediate Language, simply called \Fil from now on, is a low-level representation of a formal model. Transformations
to model checker input languages are defined over \Fil.
\subsection{Domains}

\Fil support integers and Boolean literals as well as variables of those types. A value is either a Boolean or integer
value.
\begin{align*}
    \bool \in \Bool &:= \{ \true, \false \}
    \\
    \integer \in \Integer &:= \{ \ldots, -2, -1, 0, 1, 2, \ldots \}
    \\
    \var \in \Var
    \\
    \val \in \Val &:= \Bool \mid \Integer
\end{align*}

During execution, the \textit{variable environment} stores the values of all variables, provided that a value has previously been
assigned to a variable:
\begin{align*}
	\varEnvFil \in \VarEnvFil := \Var \rightarrow \liftMissing{\Val}
\end{align*}

\subsection{Expressions}

\Fil supports only side effect free expressions. Expressions consist of literal values, read operations of variables as
well as a small set of unary and binary operator applications. The \texttt{prev} operator returns the value of a global
variable at the beginning of the current step.
\begin{align*}
	\uop \in \Uop & := - \mid \neg
	\\
    \bop \in \Bop & := {} + {} \mid {} - {} \mid {} \ast {} \mid {} / {}
                       \mid {} \% {} \mid {} > {} \mid {} < {} \mid {} \geq {} 
                       \mid {} \leq {} \mid {} = {} \mid {} \neq {}
	\\
	\expr \in \Expr & := 
		\val \mid
		\var \mid
		\prev{\var} \mid
		\unaryExpr{\uop\;}{\expr} \mid
		\binaryExpr{\;\bop\;}{\expr_1}{\expr_2}
\end{align*}

The function $\ExprSem{-} \colon \Expr \rightarrow \VarEnvFil \rightarrow \VarEnvFil \rightarrow \Val$ defines the semantics of
expressions. It is given the current variable environment and the one at the beginning of the current step.
\begin{align*}
	\ExprSem{\val} \varEnvFil \varEnvFil' &= \val \\
	\ExprSem{\var} \varEnvFil \varEnvFil' &= \varEnvFil(\var) \\
	\ExprSem{\prev{\var}} \varEnvFil \varEnvFil' &= \varEnvFil'(\var) \\
	\ExprSem{\unaryExpr{\uop\;}{\expr}} \varEnvFil \varEnvFil' &= \llbracket \uop \rrbracket (\ExprSem{\expr} \varEnvFil \varEnvFil')
	\\
	\ExprSem{\binaryExpr{\;\bop\;}{\expr_1}{\expr_2}} \varEnvFil \varEnvFil' &= \llbracket \bop \rrbracket (\ExprSem{\expr_1}
	\varEnvFil \varEnvFil', \ExprSem{\expr_2} \varEnvFil \varEnvFil')
\end{align*}

\subsection{Statements}

\Fil is an imperative, sequential, and nondeterministic language supporting skip statements, variable assignments, sequential
compositions and guarded commands.
\begin{align*}
	\stmFil \in \StmFil & :=
		\skipStm \mid 
		\assignVarStm{\var}{\expr} \mid 
		\seqStm{\stmFil_1}{\stmFil_2} \mid
		\guardedStm{\guardedClause{\expr}{\stmFil}}
\end{align*}

The nondeterministic rule system $\stmArrowFil$ defines the natural semantics of statements.
\begin{align*}
	\mathit{Configurations} \colon & \;\configurationFil{\stmFil, \varEnvFil, \varEnvFil'} \in \StmFil \times \VarEnvFil \times
	\VarEnvFil, \; \varEnvFil \in \VarEnvFil
	\\
	\mathit{Transitions} \colon & \;\configurationFil{\stmFil, \varEnvFil, \varEnvFil'} \stmArrowFil \varEnvFil''
\end{align*}

The skip statement has no effect on the variable environment and is therefore simply discarded.
\begin{equation*}
	\tag{skip}
	\configurationFil{\skipStm, \varEnvFil, \varEnvFil'}
		\stmArrowFil
	\varEnvFil
\end{equation*}

Assignments to a variable update the variable environment accordingly, replacing the variable's current value with the value
obtained from the evaluation of the assigned expression.
\begin{equation*}
	\tag{assign}
	\configurationFil{\assignVarStm{\var}{\expr}, \varEnvFil, \varEnvFil'}
		\stmArrowFil
	\varEnvFil[\var \mapsto \ExprSem{\expr} \varEnvFil \varEnvFil']
\end{equation*}

Sequential composition executes two statements sequentially, carrying along the modified variable environment.
\begin{equation*}
	\tag{seq}
	\dfrac
	{
		\configurationFil{\stmFil_1, \varEnvFil, \varEnvFil'}
			\stmArrowFil
		\varEnvFil_1
		\qquad
		\configurationFil{\stmFil_2, \varEnvFil_1, \varEnvFil'}
			\stmArrowFil
		\varEnvFil_2
	}
	{
		\configurationFil{\seqStm{\stmFil_1}{\stmFil_2}, \varEnvFil, \varEnvFil'}
			\stmArrowFil
		\varEnvFil_2
	}
\end{equation*}

Guarded commands nondeterministically choose and execute a statement whose corresponding guard evaluates to true. If no guard
evaluates to true, the rule cannot be applied and hence the program is ``stuck''.
\begin{equation*}
	\tag{cmd}
	\dfrac
	{
		\configurationFil{\stmFil_i, \varEnvFil, \varEnvFil'}
			\stmArrowFil
		\varEnvFil''
	}
	{
		\configurationFil{\guardedClause{\expr_1}{\stmFil_1} \; \ldots \; \guardedClause{\expr_n}{\stmFil_n}, \varEnvFil, \varEnvFil'}
			\stmArrowFil
		\varEnvFil''
	}
	\qquad \text{if} \quad \ExprSem{e_i} \varEnvFil \varEnvFil' = \true
\end{equation*}

A denotational definition of the statement semantics might be able to better highlight the nondeterministic nature of guarded
commands. Therefore, let the semantic relation $\StmSem{-} \colon \StmFil \rightarrow \ToSet{(\VarEnvFil \times \VarEnvFil \times
\VarEnvFil)}$ define the denotational semantics of statements as follows:
\begin{align*}
	\StmSem{\skipStm} &= \{ (\varEnvFil, \varEnvFil', \varEnvFil) \mid \varEnvFil, \varEnvFil' \in \VarEnvFil \}
	\\
	\StmSem{\assignVarStm{\var}{\expr}} &= \{ (\varEnvFil, \varEnvFil', \varEnvFil[\var \mapsto \ExprSem{\expr} \varEnvFil
	\varEnvFil']) \mid \varEnvFil, \varEnvFil' \in \VarEnvFil \}
	\\
	\StmSem{\seqStm{\stmFil_1}{\stmFil_2}} &= \StmSem{\stmFil_2} \circ \StmSem{\stmFil_1}
	\\
	\StmSem{\guardedClause{\expr_1}{\stmFil_1} \ldots \guardedClause{\expr_n}{\stmFil_n}} &= 
		\bigcup\nolimits_{i = 1}^n \,
		\{ (\varEnvFil, \varEnvFil', \varEnvFil'') \in \StmSem{\stmFil_i} \mid \ExprSem{e_i} \varEnvFil \varEnvFil' = \true \}
\end{align*}

Alternatively, we could define the semantic relation $\StmSem{-}$ by reusing rule system $\stmArrowFil$:
\begin{equation*}
	\StmSem{\stmFil} := \{ (\varEnvFil, \varEnvFil', \varEnvFil'') \in \VarEnvFil \times \VarEnvFil \times \VarEnvFil \mid
	\configurationFil{\stmFil, \varEnvFil, \varEnvFil'} \stmArrowFil \varEnvFil'' \}
\end{equation*}

\subsection{Semantics of \Fil Programs}

\Fil programs have a set of global and local variables. A \Fil program is executed in a series of steps, with each step executing
the exact same sequence of statements. There are global variables that are initialized once and whose values are preserved between
different steps of the program. Additionally, there are step-local variables whose values are not preserved between different
program steps.
\begin{equation*}
	\prog \in \Prog := \ToSet{\Var} \times \ToSet{\Var} \times (\Var \rightarrow \ToSet{\Val}) \times \StmFil
\end{equation*}

The first set of variables represents the global variables defined by a program, whereas the second set describes the step-local
ones. The function is used to determine the initial values of all (global) variables; there might be multiple initial
values for each variable. The statement of a program is executed once during each step.

\begin{samepage}
	The semantics of a \Fil program is a set of \textit{traces}, with each trace being an infinite sequence $\varEnvFil_0 \,
	\varEnvFil_1 \, \varEnvFil_2 \ldots$ of variable environments. We have $\{ \varEnvFil_0 \, \varEnvFil_1 \, \varEnvFil_2 \ldots \}
	\in \mathit{traces}(\prog \triangleright \toSet{\var}_g, \toSet{\var}_l, \mathit{init}, \stmFil)$ if
	\begin{itemize}
		\item $\forall \var \in \toSet{\var}_g \colon \varEnvFil_0(\var) \in \mathit{init}(\var)$
		\item $\forall \var \in \Var \setminus \toSet{\var}_g \colon \varEnvFil_0(\var) = \missing$
		\item $\forall i \in \mathbb{N}_0 \colon \configurationFil{\stmFil, \varEnvFil_i, \varEnvFil_i} \stmArrowFil
		\varEnvFil_{i+1}' \wedge \varEnvFil_{i+1} = \varEnvFil_{i + 1}'[\toSet{\var}_l \mapsto \missing]$
	\end{itemize}
\end{samepage}

\subsection{Well-Formedness of \Fil Programs}
\begin{itemize}
	\item All expressions and statements are typed correctly.
	\item All variables are written to before they are assigned (definitely assigned, see also discussion of well-formedness of
	formal models).
\end{itemize}

\section{Formal Models}
We're now going to define the syntactic and semantic
domains for formal models. The basic structure of a formal model is shown in~\cref{FormalModelOverview}.

\begin{lstlisting}[tabsize=4,basicstyle=\footnotesize\ttfamily,label=FormalModelOverview,caption={Basic Structure of a
Formal Model},escapeinside={(*}{*)}]
component C
{
	// subcomponents
	component D
	{
		// fields
		b : bool = false
			 
		// provided port
		X(p1 : int, p2 : int; r1 : bool, r2 : bool)
		{
			Y(;)
			r1 := false
			r2 := b1
		}
				
		// required port
		Y(;)
	}

	// fields
	x : int = 1, 2, 3
	b : bool = true, false
		
	// required port
	M(int, int; bool, bool)
		
	// provided port
	X(p1 : int, p2 : int; r1 : bool, r2 : bool)
	{
		r1 := p1 > 1
		r2 := p2 > x && b
	}	
	
	Y(;)
	{
		skip
	}
		
	// bindings
	C.M (* $\rightarrow_\mathtt{d}$ *) D.X // delayed
	D.Y (* $\rightarrow_\mathtt{i}$ *) C.Y // instantaneous
	
	// behavior
	{
		l1 : bool, l2 : bool
		M(x, x - 1; l1, l2)
		(l1 (* $\twoheadrightarrow$ *) x = x - 1; l2 (* $\twoheadrightarrow$ *) b = true)
		D() // invoke behavior of subcomponent D
	}
}
\end{lstlisting}

\subsection{Domains of Formal Models}
We assume a domain of variables that represent provided port input and output parameters as well as local variables with a default
initial value. Fields, on the other hand, represent component-global variables with one or more initial value. Required and
provided ports allow different components to communicate with each other.
\begin{align*}
	\var &\in \Var \\
	\field &\in \Field \\
	\reqPort &\in \ReqPort \\
	\provPort &\in \ProvPort \\
	\comp&\in \Comp
\end{align*}

Similar to \Fil, formal models have values of Boolean and integer type; we also have a domain of types
for those values.
\begin{align*}
    \bool \in \Bool &:= \{ \true, \false \}
    \\
    \integer \in \Integer &:= \{ \ldots, -2, -1, 0, 1, 2, \ldots \}
    \\
    \val \in \Val &:= \Bool \mid \Integer
    \\
	\type \in \Type &:= \boolType \mid \intType
\end{align*}

During execution, a \textit{variable environment} stores the values of all local variables as well as all input and output
parameters of a provided port.
A \textit{field environment} stores the values of all fields of all components in the hierarchy. Since fields are only unique
within the context of a single component, the field environment needs to know the the concrete component the field is declared
in. A component is uniquely identified by the path through the component hierarchy starting at the root and proceeding down to the
component. We occasionally use field environments in a curried form where the component path has already been provided.
\begin{align*}
	\fieldEnv \in \FieldEnv &:= \ToListNE{\Comp} \rightarrow \liftFailure{(\Field \rightarrow \liftFailure{\Val})} \\
	\fieldEnvCurried \in \FieldEnvCurried &:= \Field \rightarrow \liftFailure{\Val} \\
	\varEnvFm \in \VarEnvFm &:= \Var \rightarrow \liftFailure{\Val}
\end{align*}

$\varEnvFmEmpty$ and $\fieldEnvEmpty$ denote the empty variable and field environments, respectively. We use the standard
notation $\varEnvFm\left[\var \mapsto \val \right]$ to update the value of a variable $\var$ and also allow for simultaneous
updates, written as $\varEnvFm\left[\var_1, \ldots, \var_n \mapsto \val_1, \ldots, \val_n\right]$.
For field environments, the notation $\fieldEnv\left[\toListNE{\comp}, \field \mapsto \val \right]$ is used to update the value of
some field $\field$ within the hierarchy of components at location $\toListNE{\comp}$, where
\begin{equation*}
	\fieldEnv\left[\toListNE{\comp}, \field \mapsto \val \right](\toListNE{\comp}_0, \field_0) =
		\begin{cases}
			\val & \text{if } \toListNE{\comp} = \toListNE{\comp}_0 \wedge \field = \field_0 \\
			\fieldEnv(\toListNE{\comp}_0, \field_0) & \text{otherwise.}
		\end{cases}
\end{equation*}

We also allow for simultaneous updates of multiple fields of the same component, written as $\fieldEnv\left[\toListNE{\comp},
\field_1, \ldots, \field_n \mapsto \val_1, \ldots, \val_n \right]$ or $\fieldEnv\left[\toListNE{\comp}, \field_1, \ldots, \field_n
\mapsto \val \right]$ if all fields are updated to the same value.

\subsubsection{Expressions}
Formal models support only side effect free expressions. Expressions consist of literal values, read operations of variables
and fields as well as a small set of unary and binary operator applications.
\begin{align*}
	\uop \in \Uop & := - \mid \neg
	\\
    \bop \in \Bop & := {} + {} \mid {} - {} \mid {} \ast {} \mid {} / {}
                       \mid {} \% {} \mid {} > {} \mid {} < {} \mid {} \geq {} 
                       \mid {} \leq {} \mid {} = {} \mid {} \neq {}
	\\
	\expr \in \Expr & := 
		\val \mid
		\var \mid
		\field \mid 
		\unaryExpr{\uop\;}{\expr} \mid
		\binaryExpr{\;\bop\;}{\expr_1}{\expr_2}
\end{align*}

The function $\ExprSem{-} \colon \Expr \rightarrow \FieldEnvCurried \rightarrow \VarEnvFm \rightarrow \liftFailure{\Val}$ defines the
semantics of expressions. Since an expression of a non well-formed model might potentially accessed an undefined variable, the expression
evaluation might fail. 
\begin{align*}
	\ExprSem{\val} \fieldEnvCurried \varEnvFm &= \val \\
	\ExprSem{\var} \fieldEnvCurried \varEnvFm &= \varEnvFm(\var) \\
	\ExprSem{\field} \fieldEnvCurried \varEnvFm &= \fieldEnvCurried(\field) \\
	\ExprSem{\unaryExpr{\uop\;}{\expr}} \fieldEnvCurried \varEnvFm &= \llbracket \uop \rrbracket (\ExprSem{\expr} \fieldEnvCurried
	\varEnvFm) \\
	\ExprSem{\binaryExpr{\;\bop\;}{\expr_1}{\expr_2}} \fieldEnvCurried \varEnvFm &= \llbracket \bop \rrbracket
	(\ExprSem{\expr_1} \fieldEnvCurried \varEnvFm, \ExprSem{\expr_2} \fieldEnvCurried \varEnvFm)
\end{align*}

\subsubsection{Statements}
Formal models support skip statements, variable and field assignments, sequential compositions, guarded commands, and
invocations of required ports. Only variables but not fields are allowed as output parameters of required port invocations.
\begin{align*}
	\guardedCmd \in \GuardedCmd &:= \guardedClause{\expr}{\stmFm} \\
	\stmFm \in \StmFm &:=
		\skipStm \mid 
		\assignVarStm{\var}{\expr} \mid
		\assignVarStm{\field}{\expr} \mid
		\seqStm{\stmFm_1}{\stmFm_2} \mid
		\toListNE{\guardedCmd} \mid
		\invokePort{\reqPort}{\toList{\expr}}{\toList{\var}} \mid
		\invokeBeh{\comp}
\end{align*}

\subsubsection{Variable and Field Declarations}
A variable declaration introduces typed local variables or parameters.
A field declaration declares component fields with a non-empty set of initial values, one of which is chosen
nondeterministically when the component is executed. Fields are global within the context of the component, but cannot be accessed
by parent components or subcomponents. Variables and parameters are only in scope within a the context of a component behavior or
a provided port.
\begin{align*}
	\varDecl \in \VarDecl &:= \varDeclSyn{\var}{\type} \\
	\fieldDecl \in \FieldDecl &:= \fieldDeclSyn{\field}{\type}{\toListNE{\val}}
\end{align*}

We assume two functions $\varof \colon \VarDecl \rightarrow \Var$ and $\typeof \colon \VarDecl \rightarrow \Type$ with
$\varof(\varDeclSyn{\var}{\type}) = \var$ and $\typeof(\varDeclSyn{\var}{\type}) = \type$. Similarly for fields, we define
$\fieldof \colon \FieldDecl \rightarrow \Field$, $\typeof \colon \FieldDecl \rightarrow \Type$, and $\init \colon \FieldDecl \rightarrow
\ToSet{\Val}$ such that $\fieldof(\fieldDeclSyn{\field}{\type}{\toListNE{\val}}) = \field$,
$\typeof(\fieldDeclSyn{\field}{\type}{\toListNE{\val}}) = \type$, and
$\init(\fieldDeclSyn{\field}{\type}{\toListNE{\val}}) = \asSet(\toListNE{\val})$. We also use all of these functions
on lists of variable and field declarations, applying the function to each element of the list; for instance, $\varof(\varDecl_1
\cons \ldots \cons \varDecl_n) = \varof(\varDecl_1) \cons \ldots \cons \varof(\varDecl_n)$.

\subsubsection{Required and Provided Ports}
A required port of a component has a possibly empty list of input parameters and a possible empty list of input/output parameters. 
Provided ports are defined similarly. However, they also introduce local names for their input and input/output parameters and
declare a behavior in form of a statement, optionally also introducing additional local variables. 
\begin{align*}
	\reqPortDecl \in \ReqPortDecl &:=
		\reqPortDeclSyn{\reqPort}{\toList{\type_\mathit{in}}}{\toList{\type_\mathit{io}}}
	\\
	\provPortDecl \in \ProvPortDecl &:= \provPortDeclSyn{\provPort}
		{\toList{\varDecl}_\mathit{in}}
		{\toList{\varDecl}_\mathit{io}}
		{\toList{\varDecl}_\mathit{loc}}
		{\stmFm}
\end{align*}

The functions $\signature \colon
\ReqPortDecl \rightarrow \ToList{\Type} \times \ToList{\Type}$ and $\signature \colon \ProvPortDecl \rightarrow \ToList{\Type} \times
\ToList{\Type}$ return the signature of a required or provided port declaration, that is, the lists of input and input/output
parameter types:
$\signature(\reqPortDeclSyn{\reqPort}{\toList{\type_\mathit{in}}}{\toList{\type_\mathit{io}}}) = (\toList{\type_\mathit{in}},
\toList{\type_\mathit{io}})$ and
$\signature(\provPortDeclSyn{\provPort}{\toList{\varDecl}_\mathit{in}}{\toList{\varDecl}_\mathit{io}}{\toList{\varDecl}_\mathit{loc}}{\stmFm})
= (\typeof(\toList{\var_{\mathit{in}}}), \typeof(\toList{\var_{\mathit{io}}}))$.

\subsubsection{Bindings}
A binding binds a required port to a provided port. The binding must be either between two components on the
same level within the hierarchy or must span at most one level of the hierarchy. A binding can be either
instantaneous or delayed. When a required port with a delayed binding is invoked, the corresponding provided port is executed
at the beginning of the next step with the provided parameters, the computed results are cached and the results of the invocation
of the previous state are returned. If the same provided port is invoked multiple times in a delayed fashion, the results are also
cached multiple times, always returning the computed values during the next step that corresponds to the appropriate invocation
during the current step. If the provided port does not have any incoming parameters, it suffices to cache the results once.

To uniquely identify a port of a component or a subcomponent, a binding must qualify a port with the component the port belongs
to. The component can be any of the parent component's subcomponents or to the parent component itself.
\begin{equation*} 
	\bindingDecl \in \BindingDecl :=
		\bindingDeclSyn{\qualifiedName{\comp_\reqPort}{\reqPort}}{\qualifiedName{\comp_\provPort}{\provPort}}{\instantBinding}
		\mid
		\bindingDeclSyn{\qualifiedName{\comp_\reqPort}{\reqPort}}{\qualifiedName{\comp_\provPort}{\provPort}}{\delayedBinding}
\end{equation*}

We define a substitution operation for components used within bindings as follows: Given a component $\comp$ that is to be
replaced by component $\comp'$, we update a binding $\bindingDecl$ using the notation $\bindingDecl\left[\comp \mapsto
\comp'\right]$, such that
$(\bindingDeclSyn{\qualifiedName{\comp_\reqPort}{\reqPort}}{\qualifiedName{\comp_\provPort}{\provPort}}{\anyBinding})[\comp
\mapsto \comp'] = \bindingDeclSyn{\qualifiedName{\comp_1}{\reqPort}}{\qualifiedName{\comp_2}{\provPort}}{\anyBinding}$ where
$\comp_1 = \comp_\reqPort$ if $\comp_1 \neq \comp$ and $\comp_1 = \comp'$ otherwise; and $\comp_2 = \comp_\provPort$ if $\comp_2
\neq \comp$ and $\comp_2 = \comp'$ otherwise.
For a list of bindings $\toList{\bindingDecl}$ we use the notational convention
$\toList{\bindingDecl}[\comp \mapsto \comp']$ to substitute the component in all bindings contained in the list.

\subsubsection{Components}
Components declare sets of required and provided ports, fields, port bindings and subcomponents. They have a behavior described by
a statement with optional local variables.
\begin{equation*}
	\compDecl \in \CompDecl :=  
		\compDeclSyn{\comp}
			{\toList{\compDecl}}
			{\toList{\fieldDecl}}
			{\toList{\reqPortDecl}}{\toList{\provPortDecl}}
			{\toList{\bindingDecl}}
			{\toList{\varDecl}}
			{\stmFm}
\end{equation*}

We define a couple of selector methods: $\compof \colon \CompDecl \rightarrow \Comp$ yields the component declared by the
component declaration, whereas the functions $\reqsof \colon \CompDecl \rightarrow \ToSet{\ReqPortDecl}$ and $\provsof \colon
\CompDecl \rightarrow \ToSet{\ProvPortDecl}$ return the declared required and provided ports, respectively. $\subsof \colon \CompDecl \rightarrow
\ToSet{\CompDecl}$ returns the set of subcomponent declarations of a component declaration.


We use the $\in$ operator to check whether a component declaration declares a specific subcomponent, required or provided port,
field, or binding.
For instance, for required port declarations we have
$\reqPortDeclSyn{\reqPort}{\toList{\type_\mathit{in}}}{\toList{\type_\mathit{io}}} \in
(\compDeclSyn{\comp}{\toList{\compDecl}}{\toList{\fieldDecl}}{\toList{\reqPortDecl}}{\toList{\provPortDecl}}{\toList{\bindingDecl}}{\toList{\varDecl}}{\stmFm})
\Leftrightarrow \reqPortDeclSyn{\reqPort}{\toList{\type_\mathit{in}}}{\toList{\type_\mathit{io}}} \in \toList{\reqPortDecl}$.

We are allowed to substitute a subcomponent declaration of some component declaration, provided that
the original subcomponent declaration $\compDecl'$ and the new subcomponent declaration $\compDecl''$ are port-equivalent, that is
$\reqsof(\compDecl') = \reqsof(\compDecl'')$ and $\provsof(\compDecl') = \provsof(\compDecl'')$.
We use the notation $\compDecl[\compDecl' \mapsto \compDecl'']$ to obtain a new component declaration
where $\compDecl'$ has been replaced with $\compDecl''$. Consequently,
$(\compDeclSyn{\comp}{\toList{\compDecl}}{\toList{\fieldDecl}}{\toList{\reqPortDecl}}{\toList{\provPortDecl}}{\toList{\bindingDecl}}{\toList{\varDecl}}{\stmFm})[\compDecl'
\mapsto \compDecl''] =
\compDeclSyn{\comp}{\toList{\compDecl}[\compDecl'
\mapsto \compDecl'']}{\toList{\fieldDecl}}{\toList{\reqPortDecl}}{\toList{\provPortDecl}}{\toList{\bindingDecl}[\compDecl'
\mapsto \compDecl'']}{\toList{\varDecl}}{\stmFm}$. We also allow for simultaneous substitution of multiple subcomponents, written as
$\compDecl[\compDecl_1, \ldots, \compDecl_n \mapsto \compDecl_1', \ldots, \compDecl_n']$.

We can also select a subcomponent declaration at some level of the component hierarchy using the subcomponent selector $.[.]
\colon \CompDecl \times \ToListNE{\Comp} \rightarrow \liftFailure{\CompDecl}$, defined as
\begin{align*}
	\compDecl[\comp] &= \begin{cases}
		\compDecl & \text{if } \compof(\compDecl) = \comp \\
		\failure & \text{otherwise}
	\end{cases} \\
	\compDecl[\comp1 \cons \comp_2 \cons \toList{\comp}] &= 
		\begin{cases}
			\compDecl'[\comp_2 \cons \toList{\comp}] & \text{if } 
				\compof(\compDecl) = \comp_1 \wedge \exists \compDecl' \in \compDecl \colon \compof(\compDecl') = \comp_2 \\
			\failure & \text{otherwise.}
		\end{cases}
\end{align*}

\subsection{Well-Formedness of Components}
We only consider components that are well-formed according to the following criteria:
\begin{itemize}
	\item To decide: Should we restrict calls to subcomponent behaviors to exactly one invocation per step?
	\item All expressions and statements are typed correctly.
	\item All fields, required ports, and provided ports within a component have a unique name.
	\item All subcomponents of a component have unique names; additionally, a parent component has a name that is different from the
	names of all of its subcomponents.
	\item All statements and expressions respect the scoping of parameters, locals, fields, and required ports.
	\item All bindings respect the component hierarchy: A binding connecting two ports of components $\comp_1$ and $\comp_2$ within
	the context of component $\comp$ with subcomponents $\toSet{s}$ is only well-formed if $\comp_1, \comp_2 \in \{ \comp \} \cup
	\toSet{s}$.
	\item There are no circular bindings, resulting in a provided port indirectly invoking itself. Such a circle can only be allowed
	if at least one of the involved bindings is delayed.
	\item There is exactly one binding for each required port; there can be none, one, or multiple bindings for a provided port.
	\item The ports of a binding are compatible, that is, they have the same signature (= type, order, and number of input and
	output parameters).
	\item Required ports are invoked with the correct parameters (both in type and number).
	\item All ports mentioned in a binding are actually declared in the respective component.
	\item All invoked required ports are actually declared in the component.
	\item All local variables must be definitely assigned before they are first read. Analogous to \CSharp's definite assignment.
	Definite assignment is somewhat complex to check, requiring a control flow analysis. If an unassigned variable is read, the
	semantics would just ``hang``, so we could just live with that without making definite assignment a well-formedness requirement.
	Particularly, when transforming a \SSharp model into a formal model, definite assignment is guaranteed by the \CSharp compiler
	anyway. However, the purpose of the well-formedness property is to guarantee that the resulting \Fil program
	has infinite traces only. If we don't require definite assignment, infinite traces cannot be guaranteed. Note that parameters
	of a required port are always definitely assigned (it is illegal to call a required port without the correct number and type of
	parameters) and fields always have at least one initial value, so they're also always definitely assigned.
	\item Note that we do not have to check for component cycles (i.e., a component being its own parent), as that simply cannot be
	expressed with the domains we have defined.
\end{itemize}

\subsection{Semantics of Formal Models}
The nondeterministic rule system $\stmArrowFm$ is parametrized over a component declaration or hierarchy $\compDecl$. It defines
the natural semantics of statements.
\begin{align*}
	\mathit{Configurations} \colon & \;\configurationFm{\stmFm, \fieldEnv, \varEnvFm, \toListNE{\comp}} \in \StmFm \times \FieldEnv \times
	\VarEnvFm \times \ToListNE{\Comp}, \; \configurationFm{\fieldEnv, \varEnvFm} \in \FieldEnv \times \VarEnvFm
	\\
	\mathit{Transitions} \colon & \;\configurationFm{\stmFm, \fieldEnv, \varEnvFm, \toListNE{\comp}} \stmArrowFm
	\configurationFm{\fieldEnv', \varEnvFm'}
\end{align*}

The skip statement has no effect and is therefore simply discarded.
\begin{equation*}
	\tag{skip}
	\configurationFm{\skipStm, \fieldEnv, \varEnvFm, \toListNE{\comp}}
		\stmArrowFm
	\configurationFm{\fieldEnv, \varEnvFm}
\end{equation*}

Assignments to a variable update the variable environment accordingly, replacing the variable's current value with the value
obtained from the evaluation of the assigned expression.
\begin{equation*}
	\tag{assign${}_\text{v}$}
	\configurationFm{\assignVarStm{\var}{\expr}, \fieldEnv, \varEnvFm, \toListNE{\comp}}
		\stmArrowFm
	\configurationFm{\fieldEnv, \varEnvFm[\var \mapsto \ExprSem{\expr} \fieldEnv(\toListNE{\comp}) \varEnvFm]}
\end{equation*}

Assignments to a field update the field environment accordingly, replacing the fields current value with the value
obtained from the evaluation of the assigned expression.
\begin{equation*}
	\tag{assign${}_\text{f}$}
	\configurationFm{\assignVarStm{\field}{\expr}, \fieldEnv, \varEnvFm, \toListNE{\comp}}
		\stmArrowFm
	\configurationFm{\fieldEnv[\toListNE{\comp}, \field \mapsto \ExprSem{\expr} \fieldEnv(\toListNE{\comp}) \varEnvFm], \varEnvFm}
\end{equation*}

Sequential composition executes two statements sequentially, carrying along the modified variable environment.
\begin{equation*}
	\tag{seq}
	\dfrac
	{
		\configurationFm{\stmFm_1, \fieldEnv, \varEnvFm, \toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv_1, \varEnvFm_1}
		\qquad
		\configurationFm{\stmFm_2, \fieldEnv_1, \varEnvFm_1, \toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv_2, \varEnvFm_2}
	}
	{
		\configurationFm{\seqStm{\stmFm_1}{\stmFm_2}, \fieldEnv, \varEnvFm, \toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv_2, \varEnvFm_2}
	}
\end{equation*}

Guarded commands nondeterministically choose and execute a statement whose corresponding guard evaluates to true. If no guard
evaluates to true, the rule cannot be applied and hence the program is ``stuck''.
\begin{equation*}
	\tag{cmd}
	\dfrac
	{
		\configurationFm{\stmFm_i, \fieldEnv, \varEnvFm, \toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv', \varEnvFm'}
	}
	{
		\configurationFm{\guardedClause{\expr_1}{\stmFm_1} \; \ldots \; \guardedClause{\expr_n}{\stmFm_n}, \fieldEnv, \varEnvFm,
		\toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv', \varEnvFm'}
	}
	\qquad \text{if} \quad \ExprSem{e_i} \fieldEnv(\toListNE{\comp}) \varEnvFm = \true
\end{equation*}

We define a helper function $\boundof_\compDecl \colon \ToListNE{\Comp} \times \ReqPort \rightarrow \liftFailure{(\ToListNE{\Comp}
\times \ProvPort)}$ parametrized over a component hierarchy $\compDecl$ that returns the provided port bound to a required
port as follows:
\begin{align*}
	\boundof_\compDecl(\toList{\comp} \cons \comp, \reqPort) &=
		\begin{cases}
			(\toList{\comp} \cons \comp, \provPort) & \; \, \text{if } 
				\bindingDeclSyn{\qualifiedName{\comp}{\reqPort}}{\qualifiedName{\comp}{\provPort}}{\instantBinding} \in
				\compDecl[\toList{\comp} \cons \comp] \\
			(\toList{\comp} \cons \comp \cons \comp', \provPort) & \; \, \text{if } 
				\bindingDeclSyn{\qualifiedName{\comp}{\reqPort}}{\qualifiedName{\comp'}{\provPort}}{\instantBinding} \in
				\compDecl[\toList{\comp} \cons \comp] \wedge \comp' \neq \comp
		\end{cases} \\
	\boundof_\compDecl(\toList{\comp} \cons \comp_1 \cons \comp_2, \reqPort) &=
		\begin{cases}
			(\toList{\comp} \cons \comp_1, \provPort) & \text{if } 
				\bindingDeclSyn{\qualifiedName{\comp_2}{\reqPort}}{\qualifiedName{\comp_1}{\provPort}}{\instantBinding} \in
				\compDecl[\toList{\comp} \cons \comp_1] \\
			(\toList{\comp} \cons \comp_1 \cons \comp', \provPort) & \text{if } 
				\bindingDeclSyn{\qualifiedName{\comp_2}{\reqPort}}{\qualifiedName{\comp'}{\provPort}}{\instantBinding} \in
				\compDecl[\toList{\comp} \cons \comp_1] \wedge \comp' \neq \comp_2
		\end{cases}
\end{align*}

When a required port is called that is instantaneously bound to a provided port, we execute the bound port's statement.
While the field environment remains unchanged, the component context might change and the port is executed in a new, empty
variable environment in which only the values of the port's parameters are set; the values of the port's local variables remain undefined. Once we're
done with the execution of the port, we restore our previous variable environment, just taking over the port's output values.
\begin{multline*}
	\tag{call${}$}
	\dfrac
	{
		\configurationFm{\stmFm, \fieldEnv, \varEnvFmEmpty[\varof(\toList{\varDecl}_\mathit{in}), \varof(\toList{\varDecl}_\mathit{io}) \mapsto
		\ExprSem{\toList{\expr}}\fieldEnv(\toListNE{\comp})\varEnvFm, \varEnvFm(\toList{\var})],
		\toListNE{\comp}_\provPort}
			\stmArrowFm
		\configurationFm{\fieldEnv', \varEnvFm'}
	}
	{
		\configurationFm{\invokePort{\reqPort}{\toList{\expr}}{\toList{\var}}, \fieldEnv, \varEnvFm, \toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv', \varEnvFm[\toList{\var} \mapsto \varEnvFm'(\varof(\toList{\varDecl_\mathit{io}}))]}
	}
	\\ \text{if} \quad \boundof_\compDecl(\toListNE{\comp},
	\reqPort) = (\toListNE{\comp}_\provPort, \provPort) \wedge
	\provPortDeclSyn{\provPort}{\toList{\varDecl_\mathit{in}}}{\toList{\varDecl_\mathit{io}}}{\toList{\varDecl_\mathit{loc}}}{\stmFm})
	\in \compDecl[\toListNE{\comp}_\provPort]
\end{multline*}

When the behavior of a subcomponent is invoked, the subcomponent is added to the component path and an empty variable environment
is used to execute the behavior. Execution of the current behavior or port continues with the new field environment and the old
variable environment.
\begin{equation*}
	\tag{beh}
	\dfrac
	{
		\configurationFm{\stmFm, \fieldEnv, \varEnvFmEmpty, \toListNE{\comp}
		\cons \comp}
			\stmArrowFm
		\configurationFm{\fieldEnv', \varEnvFm'}
	}
	{
		\configurationFm{\invokeBeh{\comp}, \fieldEnv, \varEnvFm, \toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv', \varEnvFm}
	}
	\quad \text{if} \quad
	\compDeclSyn{\comp}{\toList{\compDecl}}{\toList{\fieldDecl}}{\toList{\reqPortDecl}}{\toList{\provPortDecl}}{\toList{\bindingDecl}}{\toList{\varDecl}}{\stmFm}
	\in \compDecl[\toListNE{\comp}]
\end{equation*}

% \begin{equation*}
% 	\tag{call${}_2$}
% 	\dfrac
% 	{
% 		\configuration{\stmof(\behavior((\comp.\compName).\provPortName)), \varEnvFmScoped, \toList{\comp} \cons \comp \cons
% 		\comp.\compName}
% 			\stmArrowFm
% 		\varEnvFmScoped'
% 	}
% 	{
% 		\configuration{\invoke{\reqPortName}{\toList{\expr}}{\toList{\varName}}, \varEnvFmScoped, \toList{\comp} \cons \comp}
% 			\stmArrowFm
% 		\varEnvFmScoped'
% 	}
% 	\quad \text{if } \bindings(\comp)[\comp, \reqPortName] = (\compName, \provPortName) \wedge \compName \neq \nameof(\comp)
% \end{equation*}
% 
% \begin{equation*}
% 	\tag{call${}_3$}
% 	\dfrac
% 	{
% 		\configuration{\stmof(\behavior(\comp.\provPortName)), \varEnvFmScoped, \toList{\comp} \cons \comp}
% 			\stmArrowFm
% 		\varEnvFmScoped'
% 	}
% 	{
% 		\configuration{\invoke{\reqPortName}{\toList{\expr}}{\toList{\varName}}, \varEnvFmScoped, \toList{\comp} \cons \comp \cons
% 		\comp'}
% 			\stmArrowFm
% 		\varEnvFmScoped'
% 	}
% 	\quad \text{if } \bindings(\comp)[\comp', \reqPortName] = (\nameof(\comp), \provPortName)
% \end{equation*}
% 
% \begin{equation*}
% 	\tag{call${}_4$}
% 	\dfrac
% 	{
% 		\configuration{\stmof(\behavior((\comp.\compName).\provPortName)), \varEnvFmScoped, \toList{\comp} \cons \comp \cons
% 		\comp.\compName}
% 			\stmArrowFm
% 		\varEnvFmScoped'
% 	}
% 	{
% 		\configuration{\invoke{\reqPortName}{\toList{\expr}}{\toList{\varName}}, \varEnvFmScoped, \toList{\comp} \cons \comp \cons
% 		\comp'}
% 			\stmArrowFm
% 		\varEnvFmScoped'
% 	}
% 	\quad \text{if } \bindings(\comp)[\comp', \reqPortName] = (\compName, \provPortName) \wedge \compName \neq \nameof(\comp)
% \end{equation*}

\subsection{Transformation to \Fil Programs}
The transformation of a well-formed formal model into a \Fil program first flattens the hierarchy in post order. That is, for a
given component, all fields, ports, and bindings are moved to the parent component, ensuring that all names remain unique. The behavior
is added at the correct location into the parent's behavior, depending on the scheduling. 

Once the hierarchy is fully flattened, all ports are inlined into the behavior of the root component. For delayed bindings, the
appropriate variables must be introduced. When the results of a delayed binding are read, the \texttt{prev} instruction must be used.

The resulting monolithic component can then be transformed in a rather straightforward way to a \Fil program.

\section{Modeling with \SafetySharp}
The general idea of the transformation process is as follows:
\begin{itemize}
	\item Compile-time
	\begin{enumerate}
		\item If the \SSharp model is not valid \CSharp code, abort.
		\item \SSharp well-formedness checks are performed. If the model is not well-formed, abort.
		\item Perform \CSharp code normalizations.
		\item For each component type in the \SSharp model, create a builder that -- at runtime -- creates a formal
		model component instance for a concrete \SSharp component instance of the component type, recursively also transforming the
		entire component subtree in post order. 
		
		For generic component types, these builders are also generic, causing the generics to be resolved by standard \DotNet
		mechanisms.
	\end{enumerate}
	
	\item Runtime
	\begin{enumerate}
		\item Initialize the component instances, running their constructors. Abort if any exceptions occur.
		\item Perform runtime well-formedness checks. Abort if the model is not well-formed.
		\item Determine the array sizes for all fields, locals and parameters of the model. Abort if there is an array for which no
		unique array size can be determined.
		\item Additional pass-through ports and the appropriate bindings must be introduced if the component has subcomponents with ports
		bound to ports of components of another partition.
		\item Synthesize a unique root component for the entire component hierarchy.
		\item Invoke the builder for the main component instance in the hierarchy tree, causing the transformation of the tree in post
		order. The result is a formal model. It is well-formed if no components defined in an external assembly are used. Otherwise, the
		formal model is only well-formed if the external assembly is not ``malicious''.
	\end{enumerate}
\end{itemize}

\subsection{Runtime Well-Formedness Checks}
Certain well-formedness checks on the \SSharp model cannot be performed at compile time, as runtime information is required:
\begin{itemize}
	\item Every component appears only once in the hierarchy (no shared components).
	\item Port bindings can optionally be checked, but this is part of the formal model well-formedness check anyway, so it can be
	skipped here.
	\begin{itemize} 
		\item Port bindings cannot be circular, unless at least one delayed binding is involved.
		\item Port bindings cannot span more than one level of the component hierarchy and cannot cross different branches of the tree,
		expect for bindings crossing partition boundaries.
		\item Every required port can only be contained in exactly one binding.
	\end{itemize}
	\item Port bindings are only allowed between compatible component types, i.e., it is invalid to bind a required port of a
	controller component to a provided port of an environment component. Note that signature compatibility is enforced by the \CSharp
	compiler.
	\item It must be possible to uniquely determine the sizes of all arrays used throughout the component hierarchy (either as local
	variables, port parameters, or fields). 
\end{itemize}

\subsection{Transformation to Formal Models}
All \SSharp models are valid \CSharp code. At compile time, additional \SSharp-specific checks are made on the
\CSharp code that guarantee that the code can be successfully transformed and that the transformed formal model is well-formed.
Even if the \CSharp code is error-free, the generated formal model must be checked for well-formedness, especially when components
from external \SSharp assemblies are used.

Certain \CSharp features that can be used when writing \SSharp models are normalized to other, semantically equivalent
\CSharp features, in order to reduce the complexity of the transformation to formal models. Component initialization and
construction use standard \CSharp/\DotNet mechanisms.

The following normalization are performed on the \CSharp code. The resulting (still valid) \CSharp code should be straightforward
to transform into a formal model.
\begin{itemize}
	\item State machines must be transformed to equivalent imperative code.
	\item Implementation inheritance is flattened. 
	\item Properties and indexers are replaced with the appropriate getter or setter methods.
	\item Variables of enum type are replaced by \texttt{int}, enum values are replaced by their underlying integer value.
	\item Compound assignment operators (\texttt{+=}, \texttt{-=}, etc.) are replaced by the appropriate expression and a simple
	assignment.
	\item Multiple local variables declared by the same declaration are split into multiple declarations.
	\item All locally declared variables that are not initialized during declaration are initialized to their default value.
	\item Additional required ports must be introduced for all provided ports of subcomponents invoked by the parent component. The
	corresponding provided port invocations have to be replaced by the synthesized required ports and the corresponding bindings have
	to be established.
	\item All methods calls (both helper methods and invocations of other provided ports of the same component) must be inlined. The
	only invocations allowed to remain are invocations of required ports.
	\item All ports are rewritten such that they have a \texttt{void} return type, with the returned values written to newly
	introduced \texttt{ref} parameters. All invocations are normalized accordingly.
	\item If a port contains \texttt{out} parameters, the \texttt{out} keyword is replaced with \texttt{ref}.
	\item If a port contains \texttt{ref} parameters, all of those parameters are moved to the end of the method signature.
	\item All invocations that have fields as \texttt{ref} parameters are rewritten such that for all field \texttt{ref} parameters new variables are
	introduced that are used as the \texttt{ref} parameters instead of the fields. After the invocation, the values of these
	variables are assigned to the corresponding field.
	\item Expressions must be rewritten such that they contain no side effects (assignments to variables, method calls, overloaded
	operators).
	\item Fields, local variables, properties, indexers and parameters of struct or array type must be replaced by the appropriate
	number of flattened elements. Structs and arrays can be recursive in the sense that a struct can contain an array of structs,
	and so on. Structs can be replaced at compile time. Arrays cannot be replaced at compile time, as the size of an array can
	generally only be determined at run-time when the port bindings have been established. It is an error if no unique size can be
	determined. Code accessing array or struct elements must be rewritten accordingly. Operations on arrays (Linq-like functions or
	\texttt{foreach} loops) must be unrolled. For arrays, the builders generate the appropriate instructions dynamically at runtime
	based on the determined array size.
\end{itemize}

\end{document}

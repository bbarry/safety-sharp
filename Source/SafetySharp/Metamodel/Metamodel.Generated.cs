//------------------------------------------------------------------------------
// <auto-generated>
//     Generated by the 'Generator.fsx' script.
//     Tuesday, 29 April 2014, 11:13:36
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace SafetySharp.Metamodel
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Metamodel.Declarations;
    using SafetySharp.Metamodel.Expressions;
    using SafetySharp.Metamodel.Statements;
    using SafetySharp.Metamodel.TypeReferences;
    using SafetySharp.Metamodel.Instances;

    public partial class Identifier : MetamodelElement
    {
        /// <summary>
        ///     Gets the name of the identifier.
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="Identifier" /> class.
        /// </summary>
        /// <param name="name">The name of the identifier.</param>
        public Identifier(string name)
            : base()
        {
            Assert.ArgumentNotNullOrWhitespace(name, () => name);

            Validate(name);
            Name = name;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="name">The name of the identifier.</param>
        partial void Validate(string name);

        /// <summary>
        ///     Creates a copy of the <see cref="Identifier" /> instance, changing only the value of the
        ///     <see cref="Identifier.Name" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="name">The name of the identifier.</param>
        public Identifier WithName(string name)
        {
            return Update(name);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="Identifier" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="name">The name of the identifier.</param>
        public Identifier Update(string name)
        {
            if (Name != name)
                return new Identifier(name);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitIdentifier(Identifier)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitIdentifier(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitIdentifier(Identifier)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitIdentifier(this);
        }
    }
}

namespace SafetySharp.Metamodel.Declarations
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Metamodel;
    using SafetySharp.Metamodel.Expressions;
    using SafetySharp.Metamodel.Statements;
    using SafetySharp.Metamodel.TypeReferences;
    using SafetySharp.Metamodel.Instances;

    public abstract partial class TypeDeclaration : MetamodelElement
    {
        /// <summary>
        ///     Gets the name of the declared type.
        /// </summary>
        public Identifier Name { get; private set; }

        /// <summary>
        ///     Gets the namespace the type is declared in.
        /// </summary>
        public string Namespace { get; private set; }

        /// <summary>
        ///     Gets the declared members of the type.
        /// </summary>
        public ImmutableArray<MemberDeclaration> Members { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="TypeDeclaration" /> class.
        /// </summary>
        /// <param name="name">The name of the declared type.</param>
        /// <param name="namespace">The namespace the type is declared in.</param>
        /// <param name="members">The declared members of the type.</param>
        protected TypeDeclaration(Identifier name, string @namespace, ImmutableArray<MemberDeclaration> members)
            : base()
        {
            Assert.ArgumentNotNull(name, () => name);
            Assert.ArgumentNotNullOrWhitespace(@namespace, () => @namespace);

            Validate(name, @namespace, members);
            Name = name;
            Namespace = @namespace;
            Members = members;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="name">The name of the declared type.</param>
        /// <param name="namespace">The namespace the type is declared in.</param>
        /// <param name="members">The declared members of the type.</param>
        partial void Validate(Identifier name, string @namespace, ImmutableArray<MemberDeclaration> members);
    }

    public partial class ComponentDeclaration : TypeDeclaration
    {
        /// <summary>
        ///     Gets the statement representing the Update method of the component.
        /// </summary>
        public Statement UpdateStatement { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ComponentDeclaration" /> class.
        /// </summary>
        /// <param name="name">The name of the declared type.</param>
        /// <param name="namespace">The namespace the type is declared in.</param>
        /// <param name="members">The declared members of the type.</param>
        /// <param name="updateStatement">The statement representing the Update method of the component.</param>
        public ComponentDeclaration(Identifier name, string @namespace, ImmutableArray<MemberDeclaration> members, Statement updateStatement)
            : base(name, @namespace, members)
        {
            Assert.ArgumentNotNull(updateStatement, () => updateStatement);

            Validate(updateStatement);
            UpdateStatement = updateStatement;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="updateStatement">The statement representing the Update method of the component.</param>
        partial void Validate(Statement updateStatement);

        /// <summary>
        ///     Creates a copy of the <see cref="ComponentDeclaration" /> instance, changing only the value of the
        ///     <see cref="ComponentDeclaration.Name" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="name">The name of the declared type.</param>
        public ComponentDeclaration WithName(Identifier name)
        {
            return Update(name, Namespace, Members, UpdateStatement);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="ComponentDeclaration" /> instance, changing only the value of the
        ///     <see cref="ComponentDeclaration.Namespace" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="namespace">The namespace the type is declared in.</param>
        public ComponentDeclaration WithNamespace(string @namespace)
        {
            return Update(Name, @namespace, Members, UpdateStatement);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="ComponentDeclaration" /> instance, changing only the value of the
        ///     <see cref="ComponentDeclaration.Members" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="members">The declared members of the type.</param>
        public ComponentDeclaration WithMembers(ImmutableArray<MemberDeclaration> members)
        {
            return Update(Name, Namespace, members, UpdateStatement);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="ComponentDeclaration" /> instance, changing only the value of the
        ///     <see cref="ComponentDeclaration.UpdateStatement" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="updateStatement">The statement representing the Update method of the component.</param>
        public ComponentDeclaration WithUpdateStatement(Statement updateStatement)
        {
            return Update(Name, Namespace, Members, updateStatement);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="ComponentDeclaration" /> instance, adding the given values to the
        ///     <see cref="ComponentDeclaration.Members" /> collection; if <paramref name="members" /> is empty, 
        ///     no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="members">The declared members of the type.</param>
        public ComponentDeclaration AddMembers(params MemberDeclaration[] members)
        {
            return WithMembers(Members.AddRange(members));
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="ComponentDeclaration" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="name">The name of the declared type.</param>
        /// <param name="namespace">The namespace the type is declared in.</param>
        /// <param name="members">The declared members of the type.</param>
        /// <param name="updateStatement">The statement representing the Update method of the component.</param>
        public ComponentDeclaration Update(Identifier name, string @namespace, ImmutableArray<MemberDeclaration> members, Statement updateStatement)
        {
            if (Name != name || Namespace != @namespace || Members != members || UpdateStatement != updateStatement)
                return new ComponentDeclaration(name, @namespace, members, updateStatement);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitComponentDeclaration(ComponentDeclaration)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitComponentDeclaration(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitComponentDeclaration(ComponentDeclaration)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitComponentDeclaration(this);
        }
    }

    public abstract partial class MemberDeclaration : MetamodelElement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="MemberDeclaration" /> class.
        /// </summary>
        protected MemberDeclaration()
            : base()
        {
        }
    }

    public partial class StateVariableDeclaration : MemberDeclaration
    {
        /// <summary>
        ///     Gets the name of the state variable.
        /// </summary>
        public Identifier Name { get; private set; }

        /// <summary>
        ///     Gets the type of the state variable.
        /// </summary>
        public TypeReference Type { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="StateVariableDeclaration" /> class.
        /// </summary>
        /// <param name="name">The name of the state variable.</param>
        /// <param name="type">The type of the state variable.</param>
        public StateVariableDeclaration(Identifier name, TypeReference type)
            : base()
        {
            Validate(name, type);
            Name = name;
            Type = type;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="name">The name of the state variable.</param>
        /// <param name="type">The type of the state variable.</param>
        partial void Validate(Identifier name, TypeReference type);

        /// <summary>
        ///     Creates a copy of the <see cref="StateVariableDeclaration" /> instance, changing only the value of the
        ///     <see cref="StateVariableDeclaration.Name" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="name">The name of the state variable.</param>
        public StateVariableDeclaration WithName(Identifier name)
        {
            return Update(name, Type);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="StateVariableDeclaration" /> instance, changing only the value of the
        ///     <see cref="StateVariableDeclaration.Type" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="type">The type of the state variable.</param>
        public StateVariableDeclaration WithType(TypeReference type)
        {
            return Update(Name, type);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="StateVariableDeclaration" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="name">The name of the state variable.</param>
        /// <param name="type">The type of the state variable.</param>
        public StateVariableDeclaration Update(Identifier name, TypeReference type)
        {
            if (Name != name || Type != type)
                return new StateVariableDeclaration(name, type);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitStateVariableDeclaration(StateVariableDeclaration)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitStateVariableDeclaration(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitStateVariableDeclaration(StateVariableDeclaration)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitStateVariableDeclaration(this);
        }
    }
}

namespace SafetySharp.Metamodel.Expressions
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Metamodel;
    using SafetySharp.Metamodel.Declarations;
    using SafetySharp.Metamodel.Statements;
    using SafetySharp.Metamodel.TypeReferences;
    using SafetySharp.Metamodel.Instances;

    public abstract partial class Expression : MetamodelElement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="Expression" /> class.
        /// </summary>
        protected Expression()
            : base()
        {
        }
    }

    public partial class StateVariableExpression : Expression
    {
        /// <summary>
        ///     Gets the slot of the state variable.
        /// </summary>
        public StateVariableDeclaration Variable { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="StateVariableExpression" /> class.
        /// </summary>
        /// <param name="variable">The slot of the state variable.</param>
        public StateVariableExpression(StateVariableDeclaration variable)
            : base()
        {
            Assert.ArgumentNotNull(variable, () => variable);

            Validate(variable);
            Variable = variable;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="variable">The slot of the state variable.</param>
        partial void Validate(StateVariableDeclaration variable);

        /// <summary>
        ///     Creates a copy of the <see cref="StateVariableExpression" /> instance, changing only the value of the
        ///     <see cref="StateVariableExpression.Variable" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="variable">The slot of the state variable.</param>
        public StateVariableExpression WithVariable(StateVariableDeclaration variable)
        {
            return Update(variable);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="StateVariableExpression" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="variable">The slot of the state variable.</param>
        public StateVariableExpression Update(StateVariableDeclaration variable)
        {
            if (Variable != variable)
                return new StateVariableExpression(variable);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitStateVariableExpression(StateVariableExpression)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitStateVariableExpression(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitStateVariableExpression(StateVariableExpression)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitStateVariableExpression(this);
        }
    }

    public abstract partial class Literal : Expression
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="Literal" /> class.
        /// </summary>
        protected Literal()
            : base()
        {
        }
    }

    public partial class BooleanLiteral : Literal
    {
        /// <summary>
        ///     Gets the Boolean value of the literal.
        /// </summary>
        public bool Value { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="BooleanLiteral" /> class.
        /// </summary>
        /// <param name="value">The Boolean value of the literal.</param>
        public BooleanLiteral(bool value)
            : base()
        {
            Validate(value);
            Value = value;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="value">The Boolean value of the literal.</param>
        partial void Validate(bool value);

        /// <summary>
        ///     Creates a copy of the <see cref="BooleanLiteral" /> instance, changing only the value of the
        ///     <see cref="BooleanLiteral.Value" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="value">The Boolean value of the literal.</param>
        public BooleanLiteral WithValue(bool value)
        {
            return Update(value);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="BooleanLiteral" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="value">The Boolean value of the literal.</param>
        public BooleanLiteral Update(bool value)
        {
            if (Value != value)
                return new BooleanLiteral(value);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitBooleanLiteral(BooleanLiteral)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitBooleanLiteral(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitBooleanLiteral(BooleanLiteral)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitBooleanLiteral(this);
        }
    }

    public partial class BinaryExpression : Expression
    {
        /// <summary>
        ///     Gets the expression on the left-hand side of the binary operator.
        /// </summary>
        public Expression Left { get; private set; }

        /// <summary>
        ///     Gets the operator of the binary expression.
        /// </summary>
        public BinaryOperator Operator { get; private set; }

        /// <summary>
        ///     Gets the expression on the right-hand side of the binary operator.
        /// </summary>
        public Expression Right { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="BinaryExpression" /> class.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the binary operator.</param>
        /// <param name="operator">The operator of the binary expression.</param>
        /// <param name="right">The expression on the right-hand side of the binary operator.</param>
        public BinaryExpression(Expression left, BinaryOperator @operator, Expression right)
            : base()
        {
            Assert.ArgumentNotNull(left, () => left);
            Assert.ArgumentInRange(@operator, () => @operator);
            Assert.ArgumentNotNull(right, () => right);

            Validate(left, @operator, right);
            Left = left;
            Operator = @operator;
            Right = right;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the binary operator.</param>
        /// <param name="operator">The operator of the binary expression.</param>
        /// <param name="right">The expression on the right-hand side of the binary operator.</param>
        partial void Validate(Expression left, BinaryOperator @operator, Expression right);

        /// <summary>
        ///     Creates a copy of the <see cref="BinaryExpression" /> instance, changing only the value of the
        ///     <see cref="BinaryExpression.Left" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the binary operator.</param>
        public BinaryExpression WithLeft(Expression left)
        {
            return Update(left, Operator, Right);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="BinaryExpression" /> instance, changing only the value of the
        ///     <see cref="BinaryExpression.Operator" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="operator">The operator of the binary expression.</param>
        public BinaryExpression WithOperator(BinaryOperator @operator)
        {
            return Update(Left, @operator, Right);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="BinaryExpression" /> instance, changing only the value of the
        ///     <see cref="BinaryExpression.Right" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="right">The expression on the right-hand side of the binary operator.</param>
        public BinaryExpression WithRight(Expression right)
        {
            return Update(Left, Operator, right);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="BinaryExpression" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the binary operator.</param>
        /// <param name="operator">The operator of the binary expression.</param>
        /// <param name="right">The expression on the right-hand side of the binary operator.</param>
        public BinaryExpression Update(Expression left, BinaryOperator @operator, Expression right)
        {
            if (Left != left || Operator != @operator || Right != right)
                return new BinaryExpression(left, @operator, right);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitBinaryExpression(BinaryExpression)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitBinaryExpression(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitBinaryExpression(BinaryExpression)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitBinaryExpression(this);
        }
    }

    public partial class UnaryExpression : Expression
    {
        /// <summary>
        ///     Gets the expression of the unary expression.
        /// </summary>
        public Expression Expression { get; private set; }

        /// <summary>
        ///     Gets the operator of the unary expression.
        /// </summary>
        public UnaryOperator Operator { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="UnaryExpression" /> class.
        /// </summary>
        /// <param name="expression">The expression of the unary expression.</param>
        /// <param name="operator">The operator of the unary expression.</param>
        public UnaryExpression(Expression expression, UnaryOperator @operator)
            : base()
        {
            Assert.ArgumentNotNull(expression, () => expression);
            Assert.ArgumentInRange(@operator, () => @operator);

            Validate(expression, @operator);
            Expression = expression;
            Operator = @operator;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="expression">The expression of the unary expression.</param>
        /// <param name="operator">The operator of the unary expression.</param>
        partial void Validate(Expression expression, UnaryOperator @operator);

        /// <summary>
        ///     Creates a copy of the <see cref="UnaryExpression" /> instance, changing only the value of the
        ///     <see cref="UnaryExpression.Expression" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="expression">The expression of the unary expression.</param>
        public UnaryExpression WithExpression(Expression expression)
        {
            return Update(expression, Operator);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="UnaryExpression" /> instance, changing only the value of the
        ///     <see cref="UnaryExpression.Operator" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="operator">The operator of the unary expression.</param>
        public UnaryExpression WithOperator(UnaryOperator @operator)
        {
            return Update(Expression, @operator);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="UnaryExpression" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="expression">The expression of the unary expression.</param>
        /// <param name="operator">The operator of the unary expression.</param>
        public UnaryExpression Update(Expression expression, UnaryOperator @operator)
        {
            if (Expression != expression || Operator != @operator)
                return new UnaryExpression(expression, @operator);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitUnaryExpression(UnaryExpression)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitUnaryExpression(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitUnaryExpression(UnaryExpression)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitUnaryExpression(this);
        }
    }
}

namespace SafetySharp.Metamodel.Statements
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Metamodel;
    using SafetySharp.Metamodel.Declarations;
    using SafetySharp.Metamodel.Expressions;
    using SafetySharp.Metamodel.TypeReferences;
    using SafetySharp.Metamodel.Instances;

    public abstract partial class Statement : MetamodelElement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="Statement" /> class.
        /// </summary>
        protected Statement()
            : base()
        {
        }
    }

    public partial class BlockStatement : Statement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="BlockStatement" /> class.
        /// </summary>
        public BlockStatement()
            : base()
        {
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitBlockStatement(BlockStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitBlockStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitBlockStatement(BlockStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitBlockStatement(this);
        }
    }

    public partial class ReturnStatement : Statement
    {
        /// <summary>
        ///     Gets the expression that should be evaluated and returned.
        /// </summary>
        public Expression Expression { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ReturnStatement" /> class.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated and returned.</param>
        public ReturnStatement(Expression expression)
            : base()
        {
            Assert.ArgumentNotNull(expression, () => expression);

            Validate(expression);
            Expression = expression;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated and returned.</param>
        partial void Validate(Expression expression);

        /// <summary>
        ///     Creates a copy of the <see cref="ReturnStatement" /> instance, changing only the value of the
        ///     <see cref="ReturnStatement.Expression" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated and returned.</param>
        public ReturnStatement WithExpression(Expression expression)
        {
            return Update(expression);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="ReturnStatement" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated and returned.</param>
        public ReturnStatement Update(Expression expression)
        {
            if (Expression != expression)
                return new ReturnStatement(expression);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitReturnStatement(ReturnStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitReturnStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitReturnStatement(ReturnStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitReturnStatement(this);
        }
    }

    public partial class GuardedCommandStatement : Statement
    {
        /// <summary>
        ///     Gets the clauses of the guarded command, one of which is chose nondeterministically during execution if multiple guards hold.
        /// </summary>
        public ImmutableArray<GuardedCommandClause> Clauses { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="GuardedCommandStatement" /> class.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chose nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandStatement(ImmutableArray<GuardedCommandClause> clauses)
            : base()
        {
            Validate(clauses);
            Clauses = clauses;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chose nondeterministically during execution if multiple guards hold.</param>
        partial void Validate(ImmutableArray<GuardedCommandClause> clauses);

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandStatement" /> instance, changing only the value of the
        ///     <see cref="GuardedCommandStatement.Clauses" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chose nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandStatement WithClauses(ImmutableArray<GuardedCommandClause> clauses)
        {
            return Update(clauses);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandStatement" /> instance, adding the given values to the
        ///     <see cref="GuardedCommandStatement.Clauses" /> collection; if <paramref name="clauses" /> is empty, 
        ///     no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chose nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandStatement AddClauses(params GuardedCommandClause[] clauses)
        {
            return WithClauses(Clauses.AddRange(clauses));
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="GuardedCommandStatement" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chose nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandStatement Update(ImmutableArray<GuardedCommandClause> clauses)
        {
            if (Clauses != clauses)
                return new GuardedCommandStatement(clauses);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitGuardedCommandStatement(GuardedCommandStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitGuardedCommandStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitGuardedCommandStatement(GuardedCommandStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitGuardedCommandStatement(this);
        }
    }

    public partial class GuardedCommandClause : MetamodelElement
    {
        /// <summary>
        ///     Gets the guard of the clause that determines whether the statement can be executed.
        /// </summary>
        public Expression Guard { get; private set; }

        /// <summary>
        ///     Gets the statement of the clause that can only be executed if the guard holds.
        /// </summary>
        public Statement Statement { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="GuardedCommandClause" /> class.
        /// </summary>
        /// <param name="guard">The guard of the clause that determines whether the statement can be executed.</param>
        /// <param name="statement">The statement of the clause that can only be executed if the guard holds.</param>
        public GuardedCommandClause(Expression guard, Statement statement)
            : base()
        {
            Assert.ArgumentNotNull(guard, () => guard);
            Assert.ArgumentNotNull(statement, () => statement);

            Validate(guard, statement);
            Guard = guard;
            Statement = statement;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="guard">The guard of the clause that determines whether the statement can be executed.</param>
        /// <param name="statement">The statement of the clause that can only be executed if the guard holds.</param>
        partial void Validate(Expression guard, Statement statement);

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandClause" /> instance, changing only the value of the
        ///     <see cref="GuardedCommandClause.Guard" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="guard">The guard of the clause that determines whether the statement can be executed.</param>
        public GuardedCommandClause WithGuard(Expression guard)
        {
            return Update(guard, Statement);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandClause" /> instance, changing only the value of the
        ///     <see cref="GuardedCommandClause.Statement" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="statement">The statement of the clause that can only be executed if the guard holds.</param>
        public GuardedCommandClause WithStatement(Statement statement)
        {
            return Update(Guard, statement);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="GuardedCommandClause" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="guard">The guard of the clause that determines whether the statement can be executed.</param>
        /// <param name="statement">The statement of the clause that can only be executed if the guard holds.</param>
        public GuardedCommandClause Update(Expression guard, Statement statement)
        {
            if (Guard != guard || Statement != statement)
                return new GuardedCommandClause(guard, statement);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitGuardedCommandClause(GuardedCommandClause)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitGuardedCommandClause(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitGuardedCommandClause(GuardedCommandClause)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitGuardedCommandClause(this);
        }
    }

    public partial class AssignmentStatement : Statement
    {
        /// <summary>
        ///     Gets the expression on the left-hand side of the assignment operator.
        /// </summary>
        public Expression Left { get; private set; }

        /// <summary>
        ///     Gets the expression on the right-hand side of the assignment operator.
        /// </summary>
        public Expression Right { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="AssignmentStatement" /> class.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the assignment operator.</param>
        /// <param name="right">The expression on the right-hand side of the assignment operator.</param>
        public AssignmentStatement(Expression left, Expression right)
            : base()
        {
            Assert.ArgumentNotNull(left, () => left);
            Assert.ArgumentNotNull(right, () => right);

            Validate(left, right);
            Left = left;
            Right = right;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the assignment operator.</param>
        /// <param name="right">The expression on the right-hand side of the assignment operator.</param>
        partial void Validate(Expression left, Expression right);

        /// <summary>
        ///     Creates a copy of the <see cref="AssignmentStatement" /> instance, changing only the value of the
        ///     <see cref="AssignmentStatement.Left" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the assignment operator.</param>
        public AssignmentStatement WithLeft(Expression left)
        {
            return Update(left, Right);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="AssignmentStatement" /> instance, changing only the value of the
        ///     <see cref="AssignmentStatement.Right" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="right">The expression on the right-hand side of the assignment operator.</param>
        public AssignmentStatement WithRight(Expression right)
        {
            return Update(Left, right);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="AssignmentStatement" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the assignment operator.</param>
        /// <param name="right">The expression on the right-hand side of the assignment operator.</param>
        public AssignmentStatement Update(Expression left, Expression right)
        {
            if (Left != left || Right != right)
                return new AssignmentStatement(left, right);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitAssignmentStatement(AssignmentStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitAssignmentStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitAssignmentStatement(AssignmentStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitAssignmentStatement(this);
        }
    }
}

namespace SafetySharp.Metamodel.TypeReferences
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Metamodel;
    using SafetySharp.Metamodel.Declarations;
    using SafetySharp.Metamodel.Expressions;
    using SafetySharp.Metamodel.Statements;
    using SafetySharp.Metamodel.Instances;

    public abstract partial class TypeReference : MetamodelElement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="TypeReference" /> class.
        /// </summary>
        protected TypeReference()
            : base()
        {
        }
    }

    public partial class VoidTypeReference : TypeReference
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="VoidTypeReference" /> class.
        /// </summary>
        public VoidTypeReference()
            : base()
        {
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitVoidTypeReference(VoidTypeReference)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitVoidTypeReference(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitVoidTypeReference(VoidTypeReference)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitVoidTypeReference(this);
        }
    }

    public partial class BooleanTypeReference : TypeReference
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="BooleanTypeReference" /> class.
        /// </summary>
        public BooleanTypeReference()
            : base()
        {
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitBooleanTypeReference(BooleanTypeReference)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitBooleanTypeReference(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitBooleanTypeReference(BooleanTypeReference)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitBooleanTypeReference(this);
        }
    }

    public partial class IntegerTypeReference : TypeReference
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="IntegerTypeReference" /> class.
        /// </summary>
        public IntegerTypeReference()
            : base()
        {
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitIntegerTypeReference(IntegerTypeReference)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitIntegerTypeReference(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitIntegerTypeReference(IntegerTypeReference)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitIntegerTypeReference(this);
        }
    }

    public partial class InterfaceTypeReference : TypeReference
    {
        /// <summary>
        ///     Gets the slot of the interface declaration in the model's type information table.
        /// </summary>
        public int Slot { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="InterfaceTypeReference" /> class.
        /// </summary>
        /// <param name="slot">The slot of the interface declaration in the model's type information table.</param>
        public InterfaceTypeReference(int slot)
            : base()
        {
            Validate(slot);
            Slot = slot;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="slot">The slot of the interface declaration in the model's type information table.</param>
        partial void Validate(int slot);

        /// <summary>
        ///     Creates a copy of the <see cref="InterfaceTypeReference" /> instance, changing only the value of the
        ///     <see cref="InterfaceTypeReference.Slot" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="slot">The slot of the interface declaration in the model's type information table.</param>
        public InterfaceTypeReference WithSlot(int slot)
        {
            return Update(slot);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="InterfaceTypeReference" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="slot">The slot of the interface declaration in the model's type information table.</param>
        public InterfaceTypeReference Update(int slot)
        {
            if (Slot != slot)
                return new InterfaceTypeReference(slot);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitInterfaceTypeReference(InterfaceTypeReference)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitInterfaceTypeReference(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitInterfaceTypeReference(InterfaceTypeReference)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitInterfaceTypeReference(this);
        }
    }
}

namespace SafetySharp.Metamodel.Instances
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Metamodel;
    using SafetySharp.Metamodel.Declarations;
    using SafetySharp.Metamodel.Expressions;
    using SafetySharp.Metamodel.Statements;
    using SafetySharp.Metamodel.TypeReferences;

    public partial class ComponentInstance : MetamodelElement
    {
        /// <summary>
        ///     Gets the initial values.
        /// </summary>
        public ImmutableArray<Expression> InitialValues { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ComponentInstance" /> class.
        /// </summary>
        /// <param name="initialValues">The initial values.</param>
        public ComponentInstance(ImmutableArray<Expression> initialValues)
            : base()
        {
            Validate(initialValues);
            InitialValues = initialValues;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="initialValues">The initial values.</param>
        partial void Validate(ImmutableArray<Expression> initialValues);

        /// <summary>
        ///     Creates a copy of the <see cref="ComponentInstance" /> instance, changing only the value of the
        ///     <see cref="ComponentInstance.InitialValues" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="initialValues">The initial values.</param>
        public ComponentInstance WithInitialValues(ImmutableArray<Expression> initialValues)
        {
            return Update(initialValues);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="ComponentInstance" /> instance, adding the given values to the
        ///     <see cref="ComponentInstance.InitialValues" /> collection; if <paramref name="initialValues" /> is empty, 
        ///     no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="initialValues">The initial values.</param>
        public ComponentInstance AddInitialValues(params Expression[] initialValues)
        {
            return WithInitialValues(InitialValues.AddRange(initialValues));
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="ComponentInstance" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="initialValues">The initial values.</param>
        public ComponentInstance Update(ImmutableArray<Expression> initialValues)
        {
            if (InitialValues != initialValues)
                return new ComponentInstance(initialValues);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitComponentInstance(ComponentInstance)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitComponentInstance(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitComponentInstance(ComponentInstance)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitComponentInstance(this);
        }
    }

    public partial class Binding : MetamodelElement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="Binding" /> class.
        /// </summary>
        public Binding()
            : base()
        {
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitBinding(Binding)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitBinding(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitBinding(Binding)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitBinding(this);
        }
    }
}

namespace SafetySharp.Metamodel
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Metamodel.Declarations;
    using SafetySharp.Metamodel.Expressions;
    using SafetySharp.Metamodel.Statements;
    using SafetySharp.Metamodel.TypeReferences;
    using SafetySharp.Metamodel.Instances;

    public abstract partial class MetamodelVisitor
    {
        /// <summary>
        ///     Visits an element of type <see cref="Identifier" />.
        /// </summary>
        /// <param name="identifier">The <see cref="Identifier" /> instance that should be visited.</param>
        public virtual void VisitIdentifier(Identifier identifier)
        {
            Assert.ArgumentNotNull(identifier, () => identifier);
        }

        /// <summary>
        ///     Visits an element of type <see cref="ComponentDeclaration" />.
        /// </summary>
        /// <param name="componentDeclaration">The <see cref="ComponentDeclaration" /> instance that should be visited.</param>
        public virtual void VisitComponentDeclaration(ComponentDeclaration componentDeclaration)
        {
            Assert.ArgumentNotNull(componentDeclaration, () => componentDeclaration);
        }

        /// <summary>
        ///     Visits an element of type <see cref="StateVariableDeclaration" />.
        /// </summary>
        /// <param name="stateVariableDeclaration">The <see cref="StateVariableDeclaration" /> instance that should be visited.</param>
        public virtual void VisitStateVariableDeclaration(StateVariableDeclaration stateVariableDeclaration)
        {
            Assert.ArgumentNotNull(stateVariableDeclaration, () => stateVariableDeclaration);
        }

        /// <summary>
        ///     Visits an element of type <see cref="StateVariableExpression" />.
        /// </summary>
        /// <param name="stateVariableExpression">The <see cref="StateVariableExpression" /> instance that should be visited.</param>
        public virtual void VisitStateVariableExpression(StateVariableExpression stateVariableExpression)
        {
            Assert.ArgumentNotNull(stateVariableExpression, () => stateVariableExpression);
        }

        /// <summary>
        ///     Visits an element of type <see cref="BooleanLiteral" />.
        /// </summary>
        /// <param name="booleanLiteral">The <see cref="BooleanLiteral" /> instance that should be visited.</param>
        public virtual void VisitBooleanLiteral(BooleanLiteral booleanLiteral)
        {
            Assert.ArgumentNotNull(booleanLiteral, () => booleanLiteral);
        }

        /// <summary>
        ///     Visits an element of type <see cref="BinaryExpression" />.
        /// </summary>
        /// <param name="binaryExpression">The <see cref="BinaryExpression" /> instance that should be visited.</param>
        public virtual void VisitBinaryExpression(BinaryExpression binaryExpression)
        {
            Assert.ArgumentNotNull(binaryExpression, () => binaryExpression);
        }

        /// <summary>
        ///     Visits an element of type <see cref="UnaryExpression" />.
        /// </summary>
        /// <param name="unaryExpression">The <see cref="UnaryExpression" /> instance that should be visited.</param>
        public virtual void VisitUnaryExpression(UnaryExpression unaryExpression)
        {
            Assert.ArgumentNotNull(unaryExpression, () => unaryExpression);
        }

        /// <summary>
        ///     Visits an element of type <see cref="BlockStatement" />.
        /// </summary>
        /// <param name="blockStatement">The <see cref="BlockStatement" /> instance that should be visited.</param>
        public virtual void VisitBlockStatement(BlockStatement blockStatement)
        {
            Assert.ArgumentNotNull(blockStatement, () => blockStatement);
        }

        /// <summary>
        ///     Visits an element of type <see cref="ReturnStatement" />.
        /// </summary>
        /// <param name="returnStatement">The <see cref="ReturnStatement" /> instance that should be visited.</param>
        public virtual void VisitReturnStatement(ReturnStatement returnStatement)
        {
            Assert.ArgumentNotNull(returnStatement, () => returnStatement);
        }

        /// <summary>
        ///     Visits an element of type <see cref="GuardedCommandStatement" />.
        /// </summary>
        /// <param name="guardedCommandStatement">The <see cref="GuardedCommandStatement" /> instance that should be visited.</param>
        public virtual void VisitGuardedCommandStatement(GuardedCommandStatement guardedCommandStatement)
        {
            Assert.ArgumentNotNull(guardedCommandStatement, () => guardedCommandStatement);
        }

        /// <summary>
        ///     Visits an element of type <see cref="GuardedCommandClause" />.
        /// </summary>
        /// <param name="guardedCommandClause">The <see cref="GuardedCommandClause" /> instance that should be visited.</param>
        public virtual void VisitGuardedCommandClause(GuardedCommandClause guardedCommandClause)
        {
            Assert.ArgumentNotNull(guardedCommandClause, () => guardedCommandClause);
        }

        /// <summary>
        ///     Visits an element of type <see cref="AssignmentStatement" />.
        /// </summary>
        /// <param name="assignmentStatement">The <see cref="AssignmentStatement" /> instance that should be visited.</param>
        public virtual void VisitAssignmentStatement(AssignmentStatement assignmentStatement)
        {
            Assert.ArgumentNotNull(assignmentStatement, () => assignmentStatement);
        }

        /// <summary>
        ///     Visits an element of type <see cref="VoidTypeReference" />.
        /// </summary>
        /// <param name="voidTypeReference">The <see cref="VoidTypeReference" /> instance that should be visited.</param>
        public virtual void VisitVoidTypeReference(VoidTypeReference voidTypeReference)
        {
            Assert.ArgumentNotNull(voidTypeReference, () => voidTypeReference);
        }

        /// <summary>
        ///     Visits an element of type <see cref="BooleanTypeReference" />.
        /// </summary>
        /// <param name="booleanTypeReference">The <see cref="BooleanTypeReference" /> instance that should be visited.</param>
        public virtual void VisitBooleanTypeReference(BooleanTypeReference booleanTypeReference)
        {
            Assert.ArgumentNotNull(booleanTypeReference, () => booleanTypeReference);
        }

        /// <summary>
        ///     Visits an element of type <see cref="IntegerTypeReference" />.
        /// </summary>
        /// <param name="integerTypeReference">The <see cref="IntegerTypeReference" /> instance that should be visited.</param>
        public virtual void VisitIntegerTypeReference(IntegerTypeReference integerTypeReference)
        {
            Assert.ArgumentNotNull(integerTypeReference, () => integerTypeReference);
        }

        /// <summary>
        ///     Visits an element of type <see cref="InterfaceTypeReference" />.
        /// </summary>
        /// <param name="interfaceTypeReference">The <see cref="InterfaceTypeReference" /> instance that should be visited.</param>
        public virtual void VisitInterfaceTypeReference(InterfaceTypeReference interfaceTypeReference)
        {
            Assert.ArgumentNotNull(interfaceTypeReference, () => interfaceTypeReference);
        }

        /// <summary>
        ///     Visits an element of type <see cref="ComponentInstance" />.
        /// </summary>
        /// <param name="componentInstance">The <see cref="ComponentInstance" /> instance that should be visited.</param>
        public virtual void VisitComponentInstance(ComponentInstance componentInstance)
        {
            Assert.ArgumentNotNull(componentInstance, () => componentInstance);
        }

        /// <summary>
        ///     Visits an element of type <see cref="Binding" />.
        /// </summary>
        /// <param name="binding">The <see cref="Binding" /> instance that should be visited.</param>
        public virtual void VisitBinding(Binding binding)
        {
            Assert.ArgumentNotNull(binding, () => binding);
        }
    }

    public abstract partial class MetamodelVisitor<TResult>
    {
        /// <summary>
        ///     Visits an element of type <see cref="Identifier" />.
        /// </summary>
        /// <param name="identifier">The <see cref="Identifier" /> instance that should be visited.</param>
        public virtual TResult VisitIdentifier(Identifier identifier)
        {
            Assert.ArgumentNotNull(identifier, () => identifier);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="ComponentDeclaration" />.
        /// </summary>
        /// <param name="componentDeclaration">The <see cref="ComponentDeclaration" /> instance that should be visited.</param>
        public virtual TResult VisitComponentDeclaration(ComponentDeclaration componentDeclaration)
        {
            Assert.ArgumentNotNull(componentDeclaration, () => componentDeclaration);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="StateVariableDeclaration" />.
        /// </summary>
        /// <param name="stateVariableDeclaration">The <see cref="StateVariableDeclaration" /> instance that should be visited.</param>
        public virtual TResult VisitStateVariableDeclaration(StateVariableDeclaration stateVariableDeclaration)
        {
            Assert.ArgumentNotNull(stateVariableDeclaration, () => stateVariableDeclaration);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="StateVariableExpression" />.
        /// </summary>
        /// <param name="stateVariableExpression">The <see cref="StateVariableExpression" /> instance that should be visited.</param>
        public virtual TResult VisitStateVariableExpression(StateVariableExpression stateVariableExpression)
        {
            Assert.ArgumentNotNull(stateVariableExpression, () => stateVariableExpression);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="BooleanLiteral" />.
        /// </summary>
        /// <param name="booleanLiteral">The <see cref="BooleanLiteral" /> instance that should be visited.</param>
        public virtual TResult VisitBooleanLiteral(BooleanLiteral booleanLiteral)
        {
            Assert.ArgumentNotNull(booleanLiteral, () => booleanLiteral);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="BinaryExpression" />.
        /// </summary>
        /// <param name="binaryExpression">The <see cref="BinaryExpression" /> instance that should be visited.</param>
        public virtual TResult VisitBinaryExpression(BinaryExpression binaryExpression)
        {
            Assert.ArgumentNotNull(binaryExpression, () => binaryExpression);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="UnaryExpression" />.
        /// </summary>
        /// <param name="unaryExpression">The <see cref="UnaryExpression" /> instance that should be visited.</param>
        public virtual TResult VisitUnaryExpression(UnaryExpression unaryExpression)
        {
            Assert.ArgumentNotNull(unaryExpression, () => unaryExpression);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="BlockStatement" />.
        /// </summary>
        /// <param name="blockStatement">The <see cref="BlockStatement" /> instance that should be visited.</param>
        public virtual TResult VisitBlockStatement(BlockStatement blockStatement)
        {
            Assert.ArgumentNotNull(blockStatement, () => blockStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="ReturnStatement" />.
        /// </summary>
        /// <param name="returnStatement">The <see cref="ReturnStatement" /> instance that should be visited.</param>
        public virtual TResult VisitReturnStatement(ReturnStatement returnStatement)
        {
            Assert.ArgumentNotNull(returnStatement, () => returnStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="GuardedCommandStatement" />.
        /// </summary>
        /// <param name="guardedCommandStatement">The <see cref="GuardedCommandStatement" /> instance that should be visited.</param>
        public virtual TResult VisitGuardedCommandStatement(GuardedCommandStatement guardedCommandStatement)
        {
            Assert.ArgumentNotNull(guardedCommandStatement, () => guardedCommandStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="GuardedCommandClause" />.
        /// </summary>
        /// <param name="guardedCommandClause">The <see cref="GuardedCommandClause" /> instance that should be visited.</param>
        public virtual TResult VisitGuardedCommandClause(GuardedCommandClause guardedCommandClause)
        {
            Assert.ArgumentNotNull(guardedCommandClause, () => guardedCommandClause);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="AssignmentStatement" />.
        /// </summary>
        /// <param name="assignmentStatement">The <see cref="AssignmentStatement" /> instance that should be visited.</param>
        public virtual TResult VisitAssignmentStatement(AssignmentStatement assignmentStatement)
        {
            Assert.ArgumentNotNull(assignmentStatement, () => assignmentStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="VoidTypeReference" />.
        /// </summary>
        /// <param name="voidTypeReference">The <see cref="VoidTypeReference" /> instance that should be visited.</param>
        public virtual TResult VisitVoidTypeReference(VoidTypeReference voidTypeReference)
        {
            Assert.ArgumentNotNull(voidTypeReference, () => voidTypeReference);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="BooleanTypeReference" />.
        /// </summary>
        /// <param name="booleanTypeReference">The <see cref="BooleanTypeReference" /> instance that should be visited.</param>
        public virtual TResult VisitBooleanTypeReference(BooleanTypeReference booleanTypeReference)
        {
            Assert.ArgumentNotNull(booleanTypeReference, () => booleanTypeReference);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="IntegerTypeReference" />.
        /// </summary>
        /// <param name="integerTypeReference">The <see cref="IntegerTypeReference" /> instance that should be visited.</param>
        public virtual TResult VisitIntegerTypeReference(IntegerTypeReference integerTypeReference)
        {
            Assert.ArgumentNotNull(integerTypeReference, () => integerTypeReference);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="InterfaceTypeReference" />.
        /// </summary>
        /// <param name="interfaceTypeReference">The <see cref="InterfaceTypeReference" /> instance that should be visited.</param>
        public virtual TResult VisitInterfaceTypeReference(InterfaceTypeReference interfaceTypeReference)
        {
            Assert.ArgumentNotNull(interfaceTypeReference, () => interfaceTypeReference);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="ComponentInstance" />.
        /// </summary>
        /// <param name="componentInstance">The <see cref="ComponentInstance" /> instance that should be visited.</param>
        public virtual TResult VisitComponentInstance(ComponentInstance componentInstance)
        {
            Assert.ArgumentNotNull(componentInstance, () => componentInstance);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="Binding" />.
        /// </summary>
        /// <param name="binding">The <see cref="Binding" /> instance that should be visited.</param>
        public virtual TResult VisitBinding(Binding binding)
        {
            Assert.ArgumentNotNull(binding, () => binding);
            return default(TResult);
        }
    }

    public abstract partial class MetamodelRewriter : MetamodelVisitor<MetamodelElement>
    {
        /// <summary>
        ///     Rewrites an element of type <see cref="Identifier" />.
        /// </summary>
        /// <param name="identifier">The <see cref="Identifier" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitIdentifier(Identifier identifier)
        {
            Assert.ArgumentNotNull(identifier, () => identifier);

            var name = identifier.Name;
            return identifier.Update(name);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="ComponentDeclaration" />.
        /// </summary>
        /// <param name="componentDeclaration">The <see cref="ComponentDeclaration" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitComponentDeclaration(ComponentDeclaration componentDeclaration)
        {
            Assert.ArgumentNotNull(componentDeclaration, () => componentDeclaration);

            var name = (Identifier)Visit(componentDeclaration.Name);
            var @namespace = componentDeclaration.Namespace;
            var members = Visit(componentDeclaration.Members);
            var updateStatement = (Statement)Visit(componentDeclaration.UpdateStatement);
            return componentDeclaration.Update(name, @namespace, members, updateStatement);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="StateVariableDeclaration" />.
        /// </summary>
        /// <param name="stateVariableDeclaration">The <see cref="StateVariableDeclaration" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitStateVariableDeclaration(StateVariableDeclaration stateVariableDeclaration)
        {
            Assert.ArgumentNotNull(stateVariableDeclaration, () => stateVariableDeclaration);

            var name = (Identifier)Visit(stateVariableDeclaration.Name);
            var type = (TypeReference)Visit(stateVariableDeclaration.Type);
            return stateVariableDeclaration.Update(name, type);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="StateVariableExpression" />.
        /// </summary>
        /// <param name="stateVariableExpression">The <see cref="StateVariableExpression" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitStateVariableExpression(StateVariableExpression stateVariableExpression)
        {
            Assert.ArgumentNotNull(stateVariableExpression, () => stateVariableExpression);

            var variable = (StateVariableDeclaration)Visit(stateVariableExpression.Variable);
            return stateVariableExpression.Update(variable);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="BooleanLiteral" />.
        /// </summary>
        /// <param name="booleanLiteral">The <see cref="BooleanLiteral" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitBooleanLiteral(BooleanLiteral booleanLiteral)
        {
            Assert.ArgumentNotNull(booleanLiteral, () => booleanLiteral);

            var value = booleanLiteral.Value;
            return booleanLiteral.Update(value);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="BinaryExpression" />.
        /// </summary>
        /// <param name="binaryExpression">The <see cref="BinaryExpression" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitBinaryExpression(BinaryExpression binaryExpression)
        {
            Assert.ArgumentNotNull(binaryExpression, () => binaryExpression);

            var left = (Expression)Visit(binaryExpression.Left);
            var @operator = binaryExpression.Operator;
            var right = (Expression)Visit(binaryExpression.Right);
            return binaryExpression.Update(left, @operator, right);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="UnaryExpression" />.
        /// </summary>
        /// <param name="unaryExpression">The <see cref="UnaryExpression" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitUnaryExpression(UnaryExpression unaryExpression)
        {
            Assert.ArgumentNotNull(unaryExpression, () => unaryExpression);

            var expression = (Expression)Visit(unaryExpression.Expression);
            var @operator = unaryExpression.Operator;
            return unaryExpression.Update(expression, @operator);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="BlockStatement" />.
        /// </summary>
        /// <param name="blockStatement">The <see cref="BlockStatement" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitBlockStatement(BlockStatement blockStatement)
        {
            Assert.ArgumentNotNull(blockStatement, () => blockStatement);
            return blockStatement;
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="ReturnStatement" />.
        /// </summary>
        /// <param name="returnStatement">The <see cref="ReturnStatement" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitReturnStatement(ReturnStatement returnStatement)
        {
            Assert.ArgumentNotNull(returnStatement, () => returnStatement);

            var expression = (Expression)Visit(returnStatement.Expression);
            return returnStatement.Update(expression);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="GuardedCommandStatement" />.
        /// </summary>
        /// <param name="guardedCommandStatement">The <see cref="GuardedCommandStatement" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitGuardedCommandStatement(GuardedCommandStatement guardedCommandStatement)
        {
            Assert.ArgumentNotNull(guardedCommandStatement, () => guardedCommandStatement);

            var clauses = Visit(guardedCommandStatement.Clauses);
            return guardedCommandStatement.Update(clauses);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="GuardedCommandClause" />.
        /// </summary>
        /// <param name="guardedCommandClause">The <see cref="GuardedCommandClause" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitGuardedCommandClause(GuardedCommandClause guardedCommandClause)
        {
            Assert.ArgumentNotNull(guardedCommandClause, () => guardedCommandClause);

            var guard = (Expression)Visit(guardedCommandClause.Guard);
            var statement = (Statement)Visit(guardedCommandClause.Statement);
            return guardedCommandClause.Update(guard, statement);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="AssignmentStatement" />.
        /// </summary>
        /// <param name="assignmentStatement">The <see cref="AssignmentStatement" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitAssignmentStatement(AssignmentStatement assignmentStatement)
        {
            Assert.ArgumentNotNull(assignmentStatement, () => assignmentStatement);

            var left = (Expression)Visit(assignmentStatement.Left);
            var right = (Expression)Visit(assignmentStatement.Right);
            return assignmentStatement.Update(left, right);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="VoidTypeReference" />.
        /// </summary>
        /// <param name="voidTypeReference">The <see cref="VoidTypeReference" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitVoidTypeReference(VoidTypeReference voidTypeReference)
        {
            Assert.ArgumentNotNull(voidTypeReference, () => voidTypeReference);
            return voidTypeReference;
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="BooleanTypeReference" />.
        /// </summary>
        /// <param name="booleanTypeReference">The <see cref="BooleanTypeReference" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitBooleanTypeReference(BooleanTypeReference booleanTypeReference)
        {
            Assert.ArgumentNotNull(booleanTypeReference, () => booleanTypeReference);
            return booleanTypeReference;
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="IntegerTypeReference" />.
        /// </summary>
        /// <param name="integerTypeReference">The <see cref="IntegerTypeReference" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitIntegerTypeReference(IntegerTypeReference integerTypeReference)
        {
            Assert.ArgumentNotNull(integerTypeReference, () => integerTypeReference);
            return integerTypeReference;
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="InterfaceTypeReference" />.
        /// </summary>
        /// <param name="interfaceTypeReference">The <see cref="InterfaceTypeReference" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitInterfaceTypeReference(InterfaceTypeReference interfaceTypeReference)
        {
            Assert.ArgumentNotNull(interfaceTypeReference, () => interfaceTypeReference);

            var slot = interfaceTypeReference.Slot;
            return interfaceTypeReference.Update(slot);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="ComponentInstance" />.
        /// </summary>
        /// <param name="componentInstance">The <see cref="ComponentInstance" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitComponentInstance(ComponentInstance componentInstance)
        {
            Assert.ArgumentNotNull(componentInstance, () => componentInstance);

            var initialValues = Visit(componentInstance.InitialValues);
            return componentInstance.Update(initialValues);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="Binding" />.
        /// </summary>
        /// <param name="binding">The <see cref="Binding" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitBinding(Binding binding)
        {
            Assert.ArgumentNotNull(binding, () => binding);
            return binding;
        }
    }
}

//------------------------------------------------------------------------------
// <auto-generated>
//     Generated by the 'Metamodel.fsx' script.
//     Friday, 11 April 2014, 14:19:11
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace SafetySharp.Metamodel
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Metamodel.Declarations;
    using SafetySharp.Metamodel.Expressions;
    using SafetySharp.Metamodel.Statements;
    using SafetySharp.Metamodel.TypeReferences;

    public partial class Identifier : MetamodelElement
    {
        /// <summary>
        ///     Gets the name of the identifier.
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="Identifier" /> class.
        /// </summary>
        /// <param name="name">The name of the identifier.</param>
        public Identifier(string name)
            : base()
        {
            Assert.ArgumentNotNullOrWhitespace(name, () => name);

            Validate(name);
            Name = name;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="name">The name of the identifier.</param>
        partial void Validate(string name);

        /// <summary>
        ///     Creates a copy of the <see cref="Identifier" /> instance, changing only the value of the
        ///     <see cref="Identifier.Name" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="name">The name of the identifier.</param>
        public Identifier WithName(string name)
        {
            return Update(name);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="Identifier" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="name">The name of the identifier.</param>
        public Identifier Update(string name)
        {
            if (Name != name)
                return new Identifier(name);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitIdentifier(Identifier)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitIdentifier(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitIdentifier(Identifier)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitIdentifier(this);
        }
    }
}

namespace SafetySharp.Metamodel.Declarations
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Metamodel;
    using SafetySharp.Metamodel.Expressions;
    using SafetySharp.Metamodel.Statements;
    using SafetySharp.Metamodel.TypeReferences;

    public abstract partial class TypeDeclaration : MetamodelElement
    {
        /// <summary>
        ///     Gets the name of the declared type.
        /// </summary>
        public Identifier Name { get; private set; }

        /// <summary>
        ///     Gets the namespace the type is declared in.
        /// </summary>
        public string Namespace { get; private set; }

        /// <summary>
        ///     Gets the declared members of the type.
        /// </summary>
        public ImmutableArray<MemberDeclaration> Members { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="TypeDeclaration" /> class.
        /// </summary>
        /// <param name="name">The name of the declared type.</param>
        /// <param name="namespace">The namespace the type is declared in.</param>
        /// <param name="members">The declared members of the type.</param>
        protected TypeDeclaration(Identifier name, string @namespace, ImmutableArray<MemberDeclaration> members)
            : base()
        {
            Assert.ArgumentNotNull(name, () => name);
            Assert.ArgumentNotNullOrWhitespace(@namespace, () => @namespace);

            Validate(name, @namespace, members);
            Name = name;
            Namespace = @namespace;
            Members = members;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="name">The name of the declared type.</param>
        /// <param name="namespace">The namespace the type is declared in.</param>
        /// <param name="members">The declared members of the type.</param>
        partial void Validate(Identifier name, string @namespace, ImmutableArray<MemberDeclaration> members);
    }

    public partial class ClassDeclaration : TypeDeclaration
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="ClassDeclaration" /> class.
        /// </summary>
        /// <param name="name">The name of the declared type.</param>
        /// <param name="namespace">The namespace the type is declared in.</param>
        /// <param name="members">The declared members of the type.</param>
        public ClassDeclaration(Identifier name, string @namespace, ImmutableArray<MemberDeclaration> members)
            : base(name, @namespace, members)
        {
        }

        /// <summary>
        ///     Creates a copy of the <see cref="ClassDeclaration" /> instance, changing only the value of the
        ///     <see cref="ClassDeclaration.Name" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="name">The name of the declared type.</param>
        public ClassDeclaration WithName(Identifier name)
        {
            return Update(name, Namespace, Members);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="ClassDeclaration" /> instance, changing only the value of the
        ///     <see cref="ClassDeclaration.Namespace" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="namespace">The namespace the type is declared in.</param>
        public ClassDeclaration WithNamespace(string @namespace)
        {
            return Update(Name, @namespace, Members);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="ClassDeclaration" /> instance, changing only the value of the
        ///     <see cref="ClassDeclaration.Members" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="members">The declared members of the type.</param>
        public ClassDeclaration WithMembers(ImmutableArray<MemberDeclaration> members)
        {
            return Update(Name, Namespace, members);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="ClassDeclaration" /> instance, adding the given values to the
        ///     <see cref="ClassDeclaration.Members" /> collection; if <paramref name="members" /> is empty, 
        ///     no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="members">The declared members of the type.</param>
        public ClassDeclaration AddMembers(params MemberDeclaration[] members)
        {
            return WithMembers(Members.AddRange(members));
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="ClassDeclaration" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="name">The name of the declared type.</param>
        /// <param name="namespace">The namespace the type is declared in.</param>
        /// <param name="members">The declared members of the type.</param>
        public ClassDeclaration Update(Identifier name, string @namespace, ImmutableArray<MemberDeclaration> members)
        {
            if (Name != name || Namespace != @namespace || Members != members)
                return new ClassDeclaration(name, @namespace, members);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitClassDeclaration(ClassDeclaration)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitClassDeclaration(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitClassDeclaration(ClassDeclaration)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitClassDeclaration(this);
        }
    }

    public partial class ComponentDeclaration : TypeDeclaration
    {
        /// <summary>
        ///     Gets the statement representing the Update method of the component.
        /// </summary>
        public Statement UpdateStatement { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ComponentDeclaration" /> class.
        /// </summary>
        /// <param name="name">The name of the declared type.</param>
        /// <param name="namespace">The namespace the type is declared in.</param>
        /// <param name="members">The declared members of the type.</param>
        /// <param name="updateStatement">The statement representing the Update method of the component.</param>
        public ComponentDeclaration(Identifier name, string @namespace, ImmutableArray<MemberDeclaration> members, Statement updateStatement)
            : base(name, @namespace, members)
        {
            Assert.ArgumentNotNull(updateStatement, () => updateStatement);

            Validate(updateStatement);
            UpdateStatement = updateStatement;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="updateStatement">The statement representing the Update method of the component.</param>
        partial void Validate(Statement updateStatement);

        /// <summary>
        ///     Creates a copy of the <see cref="ComponentDeclaration" /> instance, changing only the value of the
        ///     <see cref="ComponentDeclaration.Name" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="name">The name of the declared type.</param>
        public ComponentDeclaration WithName(Identifier name)
        {
            return Update(name, Namespace, Members, UpdateStatement);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="ComponentDeclaration" /> instance, changing only the value of the
        ///     <see cref="ComponentDeclaration.Namespace" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="namespace">The namespace the type is declared in.</param>
        public ComponentDeclaration WithNamespace(string @namespace)
        {
            return Update(Name, @namespace, Members, UpdateStatement);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="ComponentDeclaration" /> instance, changing only the value of the
        ///     <see cref="ComponentDeclaration.Members" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="members">The declared members of the type.</param>
        public ComponentDeclaration WithMembers(ImmutableArray<MemberDeclaration> members)
        {
            return Update(Name, Namespace, members, UpdateStatement);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="ComponentDeclaration" /> instance, changing only the value of the
        ///     <see cref="ComponentDeclaration.UpdateStatement" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="updateStatement">The statement representing the Update method of the component.</param>
        public ComponentDeclaration WithUpdateStatement(Statement updateStatement)
        {
            return Update(Name, Namespace, Members, updateStatement);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="ComponentDeclaration" /> instance, adding the given values to the
        ///     <see cref="ComponentDeclaration.Members" /> collection; if <paramref name="members" /> is empty, 
        ///     no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="members">The declared members of the type.</param>
        public ComponentDeclaration AddMembers(params MemberDeclaration[] members)
        {
            return WithMembers(Members.AddRange(members));
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="ComponentDeclaration" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="name">The name of the declared type.</param>
        /// <param name="namespace">The namespace the type is declared in.</param>
        /// <param name="members">The declared members of the type.</param>
        /// <param name="updateStatement">The statement representing the Update method of the component.</param>
        public ComponentDeclaration Update(Identifier name, string @namespace, ImmutableArray<MemberDeclaration> members, Statement updateStatement)
        {
            if (Name != name || Namespace != @namespace || Members != members || UpdateStatement != updateStatement)
                return new ComponentDeclaration(name, @namespace, members, updateStatement);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitComponentDeclaration(ComponentDeclaration)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitComponentDeclaration(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitComponentDeclaration(ComponentDeclaration)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitComponentDeclaration(this);
        }
    }

    public abstract partial class MemberDeclaration : MetamodelElement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="MemberDeclaration" /> class.
        /// </summary>
        protected MemberDeclaration()
            : base()
        {
        }
    }

    public partial class FieldDeclaration : MemberDeclaration
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="FieldDeclaration" /> class.
        /// </summary>
        public FieldDeclaration()
            : base()
        {
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitFieldDeclaration(FieldDeclaration)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitFieldDeclaration(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitFieldDeclaration(FieldDeclaration)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitFieldDeclaration(this);
        }
    }

    public partial class PropertyDeclaration : MemberDeclaration
    {
        /// <summary>
        ///     Gets the name of the property.
        /// </summary>
        public Identifier Name { get; private set; }

        /// <summary>
        ///     Gets the type of the property.
        /// </summary>
        public TypeReference Type { get; private set; }

        /// <summary>
        ///     Gets the body of the property's getter.
        /// </summary>
        public Statement Getter { get; private set; }

        /// <summary>
        ///     Gets the body of the property's setter.
        /// </summary>
        public Statement Setter { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="PropertyDeclaration" /> class.
        /// </summary>
        /// <param name="name">The name of the property.</param>
        /// <param name="type">The type of the property.</param>
        /// <param name="getter">The body of the property's getter.</param>
        /// <param name="setter">The body of the property's setter.</param>
        public PropertyDeclaration(Identifier name, TypeReference type, Statement getter, Statement setter)
            : base()
        {
            Assert.ArgumentNotNull(type, () => type);

            Validate(name, type, getter, setter);
            Name = name;
            Type = type;
            Getter = getter;
            Setter = setter;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="name">The name of the property.</param>
        /// <param name="type">The type of the property.</param>
        /// <param name="getter">The body of the property's getter.</param>
        /// <param name="setter">The body of the property's setter.</param>
        partial void Validate(Identifier name, TypeReference type, Statement getter, Statement setter);

        /// <summary>
        ///     Creates a copy of the <see cref="PropertyDeclaration" /> instance, changing only the value of the
        ///     <see cref="PropertyDeclaration.Name" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="name">The name of the property.</param>
        public PropertyDeclaration WithName(Identifier name)
        {
            return Update(name, Type, Getter, Setter);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="PropertyDeclaration" /> instance, changing only the value of the
        ///     <see cref="PropertyDeclaration.Type" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="type">The type of the property.</param>
        public PropertyDeclaration WithType(TypeReference type)
        {
            return Update(Name, type, Getter, Setter);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="PropertyDeclaration" /> instance, changing only the value of the
        ///     <see cref="PropertyDeclaration.Getter" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="getter">The body of the property's getter.</param>
        public PropertyDeclaration WithGetter(Statement getter)
        {
            return Update(Name, Type, getter, Setter);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="PropertyDeclaration" /> instance, changing only the value of the
        ///     <see cref="PropertyDeclaration.Setter" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="setter">The body of the property's setter.</param>
        public PropertyDeclaration WithSetter(Statement setter)
        {
            return Update(Name, Type, Getter, setter);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="PropertyDeclaration" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="name">The name of the property.</param>
        /// <param name="type">The type of the property.</param>
        /// <param name="getter">The body of the property's getter.</param>
        /// <param name="setter">The body of the property's setter.</param>
        public PropertyDeclaration Update(Identifier name, TypeReference type, Statement getter, Statement setter)
        {
            if (Name != name || Type != type || Getter != getter || Setter != setter)
                return new PropertyDeclaration(name, type, getter, setter);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitPropertyDeclaration(PropertyDeclaration)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitPropertyDeclaration(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitPropertyDeclaration(PropertyDeclaration)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitPropertyDeclaration(this);
        }
    }

    public partial class StateVariableDeclaration : MemberDeclaration
    {
        /// <summary>
        ///     Gets the name of the state variable.
        /// </summary>
        public Identifier Name { get; private set; }

        /// <summary>
        ///     Gets the type of the state variable.
        /// </summary>
        public TypeReference Type { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="StateVariableDeclaration" /> class.
        /// </summary>
        /// <param name="name">The name of the state variable.</param>
        /// <param name="type">The type of the state variable.</param>
        public StateVariableDeclaration(Identifier name, TypeReference type)
            : base()
        {
            Validate(name, type);
            Name = name;
            Type = type;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="name">The name of the state variable.</param>
        /// <param name="type">The type of the state variable.</param>
        partial void Validate(Identifier name, TypeReference type);

        /// <summary>
        ///     Creates a copy of the <see cref="StateVariableDeclaration" /> instance, changing only the value of the
        ///     <see cref="StateVariableDeclaration.Name" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="name">The name of the state variable.</param>
        public StateVariableDeclaration WithName(Identifier name)
        {
            return Update(name, Type);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="StateVariableDeclaration" /> instance, changing only the value of the
        ///     <see cref="StateVariableDeclaration.Type" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="type">The type of the state variable.</param>
        public StateVariableDeclaration WithType(TypeReference type)
        {
            return Update(Name, type);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="StateVariableDeclaration" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="name">The name of the state variable.</param>
        /// <param name="type">The type of the state variable.</param>
        public StateVariableDeclaration Update(Identifier name, TypeReference type)
        {
            if (Name != name || Type != type)
                return new StateVariableDeclaration(name, type);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitStateVariableDeclaration(StateVariableDeclaration)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitStateVariableDeclaration(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitStateVariableDeclaration(StateVariableDeclaration)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitStateVariableDeclaration(this);
        }
    }
}

namespace SafetySharp.Metamodel.Expressions
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Metamodel;
    using SafetySharp.Metamodel.Declarations;
    using SafetySharp.Metamodel.Statements;
    using SafetySharp.Metamodel.TypeReferences;

    public abstract partial class Expression : MetamodelElement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="Expression" /> class.
        /// </summary>
        protected Expression()
            : base()
        {
        }
    }

    public partial class GuardedCommandClause : MetamodelElement
    {
        /// <summary>
        ///     Gets the guard of the clause that determines whether the statement can be executed.
        /// </summary>
        public Expression Guard { get; private set; }

        /// <summary>
        ///     Gets the statement of the clause that can only be executed if the guard holds.
        /// </summary>
        public Statement Statement { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="GuardedCommandClause" /> class.
        /// </summary>
        /// <param name="guard">The guard of the clause that determines whether the statement can be executed.</param>
        /// <param name="statement">The statement of the clause that can only be executed if the guard holds.</param>
        public GuardedCommandClause(Expression guard, Statement statement)
            : base()
        {
            Assert.ArgumentNotNull(guard, () => guard);
            Assert.ArgumentNotNull(statement, () => statement);

            Validate(guard, statement);
            Guard = guard;
            Statement = statement;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="guard">The guard of the clause that determines whether the statement can be executed.</param>
        /// <param name="statement">The statement of the clause that can only be executed if the guard holds.</param>
        partial void Validate(Expression guard, Statement statement);

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandClause" /> instance, changing only the value of the
        ///     <see cref="GuardedCommandClause.Guard" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="guard">The guard of the clause that determines whether the statement can be executed.</param>
        public GuardedCommandClause WithGuard(Expression guard)
        {
            return Update(guard, Statement);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandClause" /> instance, changing only the value of the
        ///     <see cref="GuardedCommandClause.Statement" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="statement">The statement of the clause that can only be executed if the guard holds.</param>
        public GuardedCommandClause WithStatement(Statement statement)
        {
            return Update(Guard, statement);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="GuardedCommandClause" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="guard">The guard of the clause that determines whether the statement can be executed.</param>
        /// <param name="statement">The statement of the clause that can only be executed if the guard holds.</param>
        public GuardedCommandClause Update(Expression guard, Statement statement)
        {
            if (Guard != guard || Statement != statement)
                return new GuardedCommandClause(guard, statement);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitGuardedCommandClause(GuardedCommandClause)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitGuardedCommandClause(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitGuardedCommandClause(GuardedCommandClause)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitGuardedCommandClause(this);
        }
    }

    public partial class GuardedCommandExpression : Expression
    {
        /// <summary>
        ///     Gets the clauses of the guarded command, one of which is chose nondeterministically during execution if multiple guards hold.
        /// </summary>
        public ImmutableArray<GuardedCommandClause> Clauses { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="GuardedCommandExpression" /> class.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chose nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandExpression(ImmutableArray<GuardedCommandClause> clauses)
            : base()
        {
            Validate(clauses);
            Clauses = clauses;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chose nondeterministically during execution if multiple guards hold.</param>
        partial void Validate(ImmutableArray<GuardedCommandClause> clauses);

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandExpression" /> instance, changing only the value of the
        ///     <see cref="GuardedCommandExpression.Clauses" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chose nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandExpression WithClauses(ImmutableArray<GuardedCommandClause> clauses)
        {
            return Update(clauses);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandExpression" /> instance, adding the given values to the
        ///     <see cref="GuardedCommandExpression.Clauses" /> collection; if <paramref name="clauses" /> is empty, 
        ///     no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chose nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandExpression AddClauses(params GuardedCommandClause[] clauses)
        {
            return WithClauses(Clauses.AddRange(clauses));
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="GuardedCommandExpression" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chose nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandExpression Update(ImmutableArray<GuardedCommandClause> clauses)
        {
            if (Clauses != clauses)
                return new GuardedCommandExpression(clauses);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitGuardedCommandExpression(GuardedCommandExpression)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitGuardedCommandExpression(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitGuardedCommandExpression(GuardedCommandExpression)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitGuardedCommandExpression(this);
        }
    }

    public partial class AssignmentExpression : Expression
    {
        /// <summary>
        ///     Gets the expression on the left-hand side of the assignment operator.
        /// </summary>
        public Expression Left { get; private set; }

        /// <summary>
        ///     Gets the expression on the right-hand side of the assignment operator.
        /// </summary>
        public Expression Right { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="AssignmentExpression" /> class.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the assignment operator.</param>
        /// <param name="right">The expression on the right-hand side of the assignment operator.</param>
        public AssignmentExpression(Expression left, Expression right)
            : base()
        {
            Assert.ArgumentNotNull(left, () => left);
            Assert.ArgumentNotNull(right, () => right);

            Validate(left, right);
            Left = left;
            Right = right;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the assignment operator.</param>
        /// <param name="right">The expression on the right-hand side of the assignment operator.</param>
        partial void Validate(Expression left, Expression right);

        /// <summary>
        ///     Creates a copy of the <see cref="AssignmentExpression" /> instance, changing only the value of the
        ///     <see cref="AssignmentExpression.Left" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the assignment operator.</param>
        public AssignmentExpression WithLeft(Expression left)
        {
            return Update(left, Right);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="AssignmentExpression" /> instance, changing only the value of the
        ///     <see cref="AssignmentExpression.Right" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="right">The expression on the right-hand side of the assignment operator.</param>
        public AssignmentExpression WithRight(Expression right)
        {
            return Update(Left, right);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="AssignmentExpression" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the assignment operator.</param>
        /// <param name="right">The expression on the right-hand side of the assignment operator.</param>
        public AssignmentExpression Update(Expression left, Expression right)
        {
            if (Left != left || Right != right)
                return new AssignmentExpression(left, right);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitAssignmentExpression(AssignmentExpression)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitAssignmentExpression(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitAssignmentExpression(AssignmentExpression)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitAssignmentExpression(this);
        }
    }

    public partial class StateVariableExpression : Expression
    {
        /// <summary>
        ///     Gets the slot of the state variable.
        /// </summary>
        public StateVariableDeclaration Variable { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="StateVariableExpression" /> class.
        /// </summary>
        /// <param name="variable">The slot of the state variable.</param>
        public StateVariableExpression(StateVariableDeclaration variable)
            : base()
        {
            Assert.ArgumentNotNull(variable, () => variable);

            Validate(variable);
            Variable = variable;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="variable">The slot of the state variable.</param>
        partial void Validate(StateVariableDeclaration variable);

        /// <summary>
        ///     Creates a copy of the <see cref="StateVariableExpression" /> instance, changing only the value of the
        ///     <see cref="StateVariableExpression.Variable" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="variable">The slot of the state variable.</param>
        public StateVariableExpression WithVariable(StateVariableDeclaration variable)
        {
            return Update(variable);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="StateVariableExpression" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="variable">The slot of the state variable.</param>
        public StateVariableExpression Update(StateVariableDeclaration variable)
        {
            if (Variable != variable)
                return new StateVariableExpression(variable);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitStateVariableExpression(StateVariableExpression)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitStateVariableExpression(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitStateVariableExpression(StateVariableExpression)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitStateVariableExpression(this);
        }
    }

    public partial class BooleanLiteral : Expression
    {
        /// <summary>
        ///     Gets the Boolean value of the literal.
        /// </summary>
        public bool Value { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="BooleanLiteral" /> class.
        /// </summary>
        /// <param name="value">The Boolean value of the literal.</param>
        public BooleanLiteral(bool value)
            : base()
        {
            Validate(value);
            Value = value;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="value">The Boolean value of the literal.</param>
        partial void Validate(bool value);

        /// <summary>
        ///     Creates a copy of the <see cref="BooleanLiteral" /> instance, changing only the value of the
        ///     <see cref="BooleanLiteral.Value" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="value">The Boolean value of the literal.</param>
        public BooleanLiteral WithValue(bool value)
        {
            return Update(value);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="BooleanLiteral" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="value">The Boolean value of the literal.</param>
        public BooleanLiteral Update(bool value)
        {
            if (Value != value)
                return new BooleanLiteral(value);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitBooleanLiteral(BooleanLiteral)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitBooleanLiteral(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitBooleanLiteral(BooleanLiteral)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitBooleanLiteral(this);
        }
    }
}

namespace SafetySharp.Metamodel.Statements
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Metamodel;
    using SafetySharp.Metamodel.Declarations;
    using SafetySharp.Metamodel.Expressions;
    using SafetySharp.Metamodel.TypeReferences;

    public abstract partial class Statement : MetamodelElement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="Statement" /> class.
        /// </summary>
        protected Statement()
            : base()
        {
        }
    }

    public partial class ExpressionStatement : Statement
    {
        /// <summary>
        ///     Gets the expression that should be treated as a statement.
        /// </summary>
        public Expression Expression { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ExpressionStatement" /> class.
        /// </summary>
        /// <param name="expression">The expression that should be treated as a statement.</param>
        public ExpressionStatement(Expression expression)
            : base()
        {
            Assert.ArgumentNotNull(expression, () => expression);

            Validate(expression);
            Expression = expression;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="expression">The expression that should be treated as a statement.</param>
        partial void Validate(Expression expression);

        /// <summary>
        ///     Creates a copy of the <see cref="ExpressionStatement" /> instance, changing only the value of the
        ///     <see cref="ExpressionStatement.Expression" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="expression">The expression that should be treated as a statement.</param>
        public ExpressionStatement WithExpression(Expression expression)
        {
            return Update(expression);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="ExpressionStatement" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="expression">The expression that should be treated as a statement.</param>
        public ExpressionStatement Update(Expression expression)
        {
            if (Expression != expression)
                return new ExpressionStatement(expression);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitExpressionStatement(ExpressionStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitExpressionStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitExpressionStatement(ExpressionStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitExpressionStatement(this);
        }
    }

    public partial class BlockStatement : Statement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="BlockStatement" /> class.
        /// </summary>
        public BlockStatement()
            : base()
        {
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitBlockStatement(BlockStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitBlockStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitBlockStatement(BlockStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitBlockStatement(this);
        }
    }

    public partial class ReturnStatement : Statement
    {
        /// <summary>
        ///     Gets the expression that should be evaluated and returned.
        /// </summary>
        public Expression Expression { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ReturnStatement" /> class.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated and returned.</param>
        public ReturnStatement(Expression expression)
            : base()
        {
            Assert.ArgumentNotNull(expression, () => expression);

            Validate(expression);
            Expression = expression;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated and returned.</param>
        partial void Validate(Expression expression);

        /// <summary>
        ///     Creates a copy of the <see cref="ReturnStatement" /> instance, changing only the value of the
        ///     <see cref="ReturnStatement.Expression" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated and returned.</param>
        public ReturnStatement WithExpression(Expression expression)
        {
            return Update(expression);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="ReturnStatement" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated and returned.</param>
        public ReturnStatement Update(Expression expression)
        {
            if (Expression != expression)
                return new ReturnStatement(expression);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitReturnStatement(ReturnStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitReturnStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitReturnStatement(ReturnStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitReturnStatement(this);
        }
    }
}

namespace SafetySharp.Metamodel.TypeReferences
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Metamodel;
    using SafetySharp.Metamodel.Declarations;
    using SafetySharp.Metamodel.Expressions;
    using SafetySharp.Metamodel.Statements;

    public abstract partial class TypeReference : MetamodelElement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="TypeReference" /> class.
        /// </summary>
        protected TypeReference()
            : base()
        {
        }
    }

    public partial class VoidTypeReference : TypeReference
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="VoidTypeReference" /> class.
        /// </summary>
        public VoidTypeReference()
            : base()
        {
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitVoidTypeReference(VoidTypeReference)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitVoidTypeReference(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitVoidTypeReference(VoidTypeReference)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitVoidTypeReference(this);
        }
    }

    public partial class BooleanTypeReference : TypeReference
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="BooleanTypeReference" /> class.
        /// </summary>
        public BooleanTypeReference()
            : base()
        {
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitBooleanTypeReference(BooleanTypeReference)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitBooleanTypeReference(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitBooleanTypeReference(BooleanTypeReference)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitBooleanTypeReference(this);
        }
    }

    public partial class IntegerTypeReference : TypeReference
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="IntegerTypeReference" /> class.
        /// </summary>
        public IntegerTypeReference()
            : base()
        {
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitIntegerTypeReference(IntegerTypeReference)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitIntegerTypeReference(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitIntegerTypeReference(IntegerTypeReference)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitIntegerTypeReference(this);
        }
    }

    public partial class InterfaceTypeReference : TypeReference
    {
        /// <summary>
        ///     Gets the slot of the interface declaration in the model's type information table.
        /// </summary>
        public int Slot { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="InterfaceTypeReference" /> class.
        /// </summary>
        /// <param name="slot">The slot of the interface declaration in the model's type information table.</param>
        public InterfaceTypeReference(int slot)
            : base()
        {
            Validate(slot);
            Slot = slot;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="slot">The slot of the interface declaration in the model's type information table.</param>
        partial void Validate(int slot);

        /// <summary>
        ///     Creates a copy of the <see cref="InterfaceTypeReference" /> instance, changing only the value of the
        ///     <see cref="InterfaceTypeReference.Slot" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="slot">The slot of the interface declaration in the model's type information table.</param>
        public InterfaceTypeReference WithSlot(int slot)
        {
            return Update(slot);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="InterfaceTypeReference" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="slot">The slot of the interface declaration in the model's type information table.</param>
        public InterfaceTypeReference Update(int slot)
        {
            if (Slot != slot)
                return new InterfaceTypeReference(slot);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor.VisitInterfaceTypeReference(InterfaceTypeReference)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(MetamodelVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitInterfaceTypeReference(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="MetamodelVisitor{TResult}.VisitInterfaceTypeReference(InterfaceTypeReference)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(MetamodelVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitInterfaceTypeReference(this);
        }
    }
}

namespace SafetySharp.Metamodel
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Metamodel.Declarations;
    using SafetySharp.Metamodel.Expressions;
    using SafetySharp.Metamodel.Statements;
    using SafetySharp.Metamodel.TypeReferences;

    public abstract partial class MetamodelVisitor
    {
        /// <summary>
        ///     Visits a metamodel element of type <see cref="Identifier" />.
        /// </summary>
        /// <param name="identifier">The <see cref="Identifier" /> instance that should be visited.</param>
        public virtual void VisitIdentifier(Identifier identifier)
        {
            Assert.ArgumentNotNull(identifier, () => identifier);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="ClassDeclaration" />.
        /// </summary>
        /// <param name="classDeclaration">The <see cref="ClassDeclaration" /> instance that should be visited.</param>
        public virtual void VisitClassDeclaration(ClassDeclaration classDeclaration)
        {
            Assert.ArgumentNotNull(classDeclaration, () => classDeclaration);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="ComponentDeclaration" />.
        /// </summary>
        /// <param name="componentDeclaration">The <see cref="ComponentDeclaration" /> instance that should be visited.</param>
        public virtual void VisitComponentDeclaration(ComponentDeclaration componentDeclaration)
        {
            Assert.ArgumentNotNull(componentDeclaration, () => componentDeclaration);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="FieldDeclaration" />.
        /// </summary>
        /// <param name="fieldDeclaration">The <see cref="FieldDeclaration" /> instance that should be visited.</param>
        public virtual void VisitFieldDeclaration(FieldDeclaration fieldDeclaration)
        {
            Assert.ArgumentNotNull(fieldDeclaration, () => fieldDeclaration);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="PropertyDeclaration" />.
        /// </summary>
        /// <param name="propertyDeclaration">The <see cref="PropertyDeclaration" /> instance that should be visited.</param>
        public virtual void VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration)
        {
            Assert.ArgumentNotNull(propertyDeclaration, () => propertyDeclaration);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="StateVariableDeclaration" />.
        /// </summary>
        /// <param name="stateVariableDeclaration">The <see cref="StateVariableDeclaration" /> instance that should be visited.</param>
        public virtual void VisitStateVariableDeclaration(StateVariableDeclaration stateVariableDeclaration)
        {
            Assert.ArgumentNotNull(stateVariableDeclaration, () => stateVariableDeclaration);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="GuardedCommandClause" />.
        /// </summary>
        /// <param name="guardedCommandClause">The <see cref="GuardedCommandClause" /> instance that should be visited.</param>
        public virtual void VisitGuardedCommandClause(GuardedCommandClause guardedCommandClause)
        {
            Assert.ArgumentNotNull(guardedCommandClause, () => guardedCommandClause);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="GuardedCommandExpression" />.
        /// </summary>
        /// <param name="guardedCommandExpression">The <see cref="GuardedCommandExpression" /> instance that should be visited.</param>
        public virtual void VisitGuardedCommandExpression(GuardedCommandExpression guardedCommandExpression)
        {
            Assert.ArgumentNotNull(guardedCommandExpression, () => guardedCommandExpression);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="AssignmentExpression" />.
        /// </summary>
        /// <param name="assignmentExpression">The <see cref="AssignmentExpression" /> instance that should be visited.</param>
        public virtual void VisitAssignmentExpression(AssignmentExpression assignmentExpression)
        {
            Assert.ArgumentNotNull(assignmentExpression, () => assignmentExpression);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="StateVariableExpression" />.
        /// </summary>
        /// <param name="stateVariableExpression">The <see cref="StateVariableExpression" /> instance that should be visited.</param>
        public virtual void VisitStateVariableExpression(StateVariableExpression stateVariableExpression)
        {
            Assert.ArgumentNotNull(stateVariableExpression, () => stateVariableExpression);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="BooleanLiteral" />.
        /// </summary>
        /// <param name="booleanLiteral">The <see cref="BooleanLiteral" /> instance that should be visited.</param>
        public virtual void VisitBooleanLiteral(BooleanLiteral booleanLiteral)
        {
            Assert.ArgumentNotNull(booleanLiteral, () => booleanLiteral);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="ExpressionStatement" />.
        /// </summary>
        /// <param name="expressionStatement">The <see cref="ExpressionStatement" /> instance that should be visited.</param>
        public virtual void VisitExpressionStatement(ExpressionStatement expressionStatement)
        {
            Assert.ArgumentNotNull(expressionStatement, () => expressionStatement);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="BlockStatement" />.
        /// </summary>
        /// <param name="blockStatement">The <see cref="BlockStatement" /> instance that should be visited.</param>
        public virtual void VisitBlockStatement(BlockStatement blockStatement)
        {
            Assert.ArgumentNotNull(blockStatement, () => blockStatement);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="ReturnStatement" />.
        /// </summary>
        /// <param name="returnStatement">The <see cref="ReturnStatement" /> instance that should be visited.</param>
        public virtual void VisitReturnStatement(ReturnStatement returnStatement)
        {
            Assert.ArgumentNotNull(returnStatement, () => returnStatement);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="VoidTypeReference" />.
        /// </summary>
        /// <param name="voidTypeReference">The <see cref="VoidTypeReference" /> instance that should be visited.</param>
        public virtual void VisitVoidTypeReference(VoidTypeReference voidTypeReference)
        {
            Assert.ArgumentNotNull(voidTypeReference, () => voidTypeReference);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="BooleanTypeReference" />.
        /// </summary>
        /// <param name="booleanTypeReference">The <see cref="BooleanTypeReference" /> instance that should be visited.</param>
        public virtual void VisitBooleanTypeReference(BooleanTypeReference booleanTypeReference)
        {
            Assert.ArgumentNotNull(booleanTypeReference, () => booleanTypeReference);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="IntegerTypeReference" />.
        /// </summary>
        /// <param name="integerTypeReference">The <see cref="IntegerTypeReference" /> instance that should be visited.</param>
        public virtual void VisitIntegerTypeReference(IntegerTypeReference integerTypeReference)
        {
            Assert.ArgumentNotNull(integerTypeReference, () => integerTypeReference);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="InterfaceTypeReference" />.
        /// </summary>
        /// <param name="interfaceTypeReference">The <see cref="InterfaceTypeReference" /> instance that should be visited.</param>
        public virtual void VisitInterfaceTypeReference(InterfaceTypeReference interfaceTypeReference)
        {
            Assert.ArgumentNotNull(interfaceTypeReference, () => interfaceTypeReference);
        }
    }

    public abstract partial class MetamodelVisitor<TResult>
    {
        /// <summary>
        ///     Visits a metamodel element of type <see cref="Identifier" />.
        /// </summary>
        /// <param name="identifier">The <see cref="Identifier" /> instance that should be visited.</param>
        public virtual TResult VisitIdentifier(Identifier identifier)
        {
            Assert.ArgumentNotNull(identifier, () => identifier);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="ClassDeclaration" />.
        /// </summary>
        /// <param name="classDeclaration">The <see cref="ClassDeclaration" /> instance that should be visited.</param>
        public virtual TResult VisitClassDeclaration(ClassDeclaration classDeclaration)
        {
            Assert.ArgumentNotNull(classDeclaration, () => classDeclaration);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="ComponentDeclaration" />.
        /// </summary>
        /// <param name="componentDeclaration">The <see cref="ComponentDeclaration" /> instance that should be visited.</param>
        public virtual TResult VisitComponentDeclaration(ComponentDeclaration componentDeclaration)
        {
            Assert.ArgumentNotNull(componentDeclaration, () => componentDeclaration);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="FieldDeclaration" />.
        /// </summary>
        /// <param name="fieldDeclaration">The <see cref="FieldDeclaration" /> instance that should be visited.</param>
        public virtual TResult VisitFieldDeclaration(FieldDeclaration fieldDeclaration)
        {
            Assert.ArgumentNotNull(fieldDeclaration, () => fieldDeclaration);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="PropertyDeclaration" />.
        /// </summary>
        /// <param name="propertyDeclaration">The <see cref="PropertyDeclaration" /> instance that should be visited.</param>
        public virtual TResult VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration)
        {
            Assert.ArgumentNotNull(propertyDeclaration, () => propertyDeclaration);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="StateVariableDeclaration" />.
        /// </summary>
        /// <param name="stateVariableDeclaration">The <see cref="StateVariableDeclaration" /> instance that should be visited.</param>
        public virtual TResult VisitStateVariableDeclaration(StateVariableDeclaration stateVariableDeclaration)
        {
            Assert.ArgumentNotNull(stateVariableDeclaration, () => stateVariableDeclaration);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="GuardedCommandClause" />.
        /// </summary>
        /// <param name="guardedCommandClause">The <see cref="GuardedCommandClause" /> instance that should be visited.</param>
        public virtual TResult VisitGuardedCommandClause(GuardedCommandClause guardedCommandClause)
        {
            Assert.ArgumentNotNull(guardedCommandClause, () => guardedCommandClause);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="GuardedCommandExpression" />.
        /// </summary>
        /// <param name="guardedCommandExpression">The <see cref="GuardedCommandExpression" /> instance that should be visited.</param>
        public virtual TResult VisitGuardedCommandExpression(GuardedCommandExpression guardedCommandExpression)
        {
            Assert.ArgumentNotNull(guardedCommandExpression, () => guardedCommandExpression);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="AssignmentExpression" />.
        /// </summary>
        /// <param name="assignmentExpression">The <see cref="AssignmentExpression" /> instance that should be visited.</param>
        public virtual TResult VisitAssignmentExpression(AssignmentExpression assignmentExpression)
        {
            Assert.ArgumentNotNull(assignmentExpression, () => assignmentExpression);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="StateVariableExpression" />.
        /// </summary>
        /// <param name="stateVariableExpression">The <see cref="StateVariableExpression" /> instance that should be visited.</param>
        public virtual TResult VisitStateVariableExpression(StateVariableExpression stateVariableExpression)
        {
            Assert.ArgumentNotNull(stateVariableExpression, () => stateVariableExpression);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="BooleanLiteral" />.
        /// </summary>
        /// <param name="booleanLiteral">The <see cref="BooleanLiteral" /> instance that should be visited.</param>
        public virtual TResult VisitBooleanLiteral(BooleanLiteral booleanLiteral)
        {
            Assert.ArgumentNotNull(booleanLiteral, () => booleanLiteral);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="ExpressionStatement" />.
        /// </summary>
        /// <param name="expressionStatement">The <see cref="ExpressionStatement" /> instance that should be visited.</param>
        public virtual TResult VisitExpressionStatement(ExpressionStatement expressionStatement)
        {
            Assert.ArgumentNotNull(expressionStatement, () => expressionStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="BlockStatement" />.
        /// </summary>
        /// <param name="blockStatement">The <see cref="BlockStatement" /> instance that should be visited.</param>
        public virtual TResult VisitBlockStatement(BlockStatement blockStatement)
        {
            Assert.ArgumentNotNull(blockStatement, () => blockStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="ReturnStatement" />.
        /// </summary>
        /// <param name="returnStatement">The <see cref="ReturnStatement" /> instance that should be visited.</param>
        public virtual TResult VisitReturnStatement(ReturnStatement returnStatement)
        {
            Assert.ArgumentNotNull(returnStatement, () => returnStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="VoidTypeReference" />.
        /// </summary>
        /// <param name="voidTypeReference">The <see cref="VoidTypeReference" /> instance that should be visited.</param>
        public virtual TResult VisitVoidTypeReference(VoidTypeReference voidTypeReference)
        {
            Assert.ArgumentNotNull(voidTypeReference, () => voidTypeReference);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="BooleanTypeReference" />.
        /// </summary>
        /// <param name="booleanTypeReference">The <see cref="BooleanTypeReference" /> instance that should be visited.</param>
        public virtual TResult VisitBooleanTypeReference(BooleanTypeReference booleanTypeReference)
        {
            Assert.ArgumentNotNull(booleanTypeReference, () => booleanTypeReference);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="IntegerTypeReference" />.
        /// </summary>
        /// <param name="integerTypeReference">The <see cref="IntegerTypeReference" /> instance that should be visited.</param>
        public virtual TResult VisitIntegerTypeReference(IntegerTypeReference integerTypeReference)
        {
            Assert.ArgumentNotNull(integerTypeReference, () => integerTypeReference);
            return default(TResult);
        }

        /// <summary>
        ///     Visits a metamodel element of type <see cref="InterfaceTypeReference" />.
        /// </summary>
        /// <param name="interfaceTypeReference">The <see cref="InterfaceTypeReference" /> instance that should be visited.</param>
        public virtual TResult VisitInterfaceTypeReference(InterfaceTypeReference interfaceTypeReference)
        {
            Assert.ArgumentNotNull(interfaceTypeReference, () => interfaceTypeReference);
            return default(TResult);
        }
    }

    public abstract partial class MetamodelRewriter : MetamodelVisitor<MetamodelElement>
    {
        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="Identifier" />.
        /// </summary>
        /// <param name="identifier">The <see cref="Identifier" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitIdentifier(Identifier identifier)
        {
            Assert.ArgumentNotNull(identifier, () => identifier);

            var name = identifier.Name;
            return identifier.Update(name);
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="ClassDeclaration" />.
        /// </summary>
        /// <param name="classDeclaration">The <see cref="ClassDeclaration" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitClassDeclaration(ClassDeclaration classDeclaration)
        {
            Assert.ArgumentNotNull(classDeclaration, () => classDeclaration);

            var name = (Identifier)Visit(classDeclaration.Name);
            var @namespace = classDeclaration.Namespace;
            var members = Visit(classDeclaration.Members);
            return classDeclaration.Update(name, @namespace, members);
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="ComponentDeclaration" />.
        /// </summary>
        /// <param name="componentDeclaration">The <see cref="ComponentDeclaration" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitComponentDeclaration(ComponentDeclaration componentDeclaration)
        {
            Assert.ArgumentNotNull(componentDeclaration, () => componentDeclaration);

            var name = (Identifier)Visit(componentDeclaration.Name);
            var @namespace = componentDeclaration.Namespace;
            var members = Visit(componentDeclaration.Members);
            var updateStatement = (Statement)Visit(componentDeclaration.UpdateStatement);
            return componentDeclaration.Update(name, @namespace, members, updateStatement);
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="FieldDeclaration" />.
        /// </summary>
        /// <param name="fieldDeclaration">The <see cref="FieldDeclaration" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitFieldDeclaration(FieldDeclaration fieldDeclaration)
        {
            Assert.ArgumentNotNull(fieldDeclaration, () => fieldDeclaration);
            return fieldDeclaration;
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="PropertyDeclaration" />.
        /// </summary>
        /// <param name="propertyDeclaration">The <see cref="PropertyDeclaration" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration)
        {
            Assert.ArgumentNotNull(propertyDeclaration, () => propertyDeclaration);

            var name = (Identifier)Visit(propertyDeclaration.Name);
            var type = (TypeReference)Visit(propertyDeclaration.Type);
            var getter = (Statement)Visit(propertyDeclaration.Getter);
            var setter = (Statement)Visit(propertyDeclaration.Setter);
            return propertyDeclaration.Update(name, type, getter, setter);
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="StateVariableDeclaration" />.
        /// </summary>
        /// <param name="stateVariableDeclaration">The <see cref="StateVariableDeclaration" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitStateVariableDeclaration(StateVariableDeclaration stateVariableDeclaration)
        {
            Assert.ArgumentNotNull(stateVariableDeclaration, () => stateVariableDeclaration);

            var name = (Identifier)Visit(stateVariableDeclaration.Name);
            var type = (TypeReference)Visit(stateVariableDeclaration.Type);
            return stateVariableDeclaration.Update(name, type);
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="GuardedCommandClause" />.
        /// </summary>
        /// <param name="guardedCommandClause">The <see cref="GuardedCommandClause" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitGuardedCommandClause(GuardedCommandClause guardedCommandClause)
        {
            Assert.ArgumentNotNull(guardedCommandClause, () => guardedCommandClause);

            var guard = (Expression)Visit(guardedCommandClause.Guard);
            var statement = (Statement)Visit(guardedCommandClause.Statement);
            return guardedCommandClause.Update(guard, statement);
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="GuardedCommandExpression" />.
        /// </summary>
        /// <param name="guardedCommandExpression">The <see cref="GuardedCommandExpression" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitGuardedCommandExpression(GuardedCommandExpression guardedCommandExpression)
        {
            Assert.ArgumentNotNull(guardedCommandExpression, () => guardedCommandExpression);

            var clauses = Visit(guardedCommandExpression.Clauses);
            return guardedCommandExpression.Update(clauses);
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="AssignmentExpression" />.
        /// </summary>
        /// <param name="assignmentExpression">The <see cref="AssignmentExpression" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitAssignmentExpression(AssignmentExpression assignmentExpression)
        {
            Assert.ArgumentNotNull(assignmentExpression, () => assignmentExpression);

            var left = (Expression)Visit(assignmentExpression.Left);
            var right = (Expression)Visit(assignmentExpression.Right);
            return assignmentExpression.Update(left, right);
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="StateVariableExpression" />.
        /// </summary>
        /// <param name="stateVariableExpression">The <see cref="StateVariableExpression" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitStateVariableExpression(StateVariableExpression stateVariableExpression)
        {
            Assert.ArgumentNotNull(stateVariableExpression, () => stateVariableExpression);

            var variable = (StateVariableDeclaration)Visit(stateVariableExpression.Variable);
            return stateVariableExpression.Update(variable);
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="BooleanLiteral" />.
        /// </summary>
        /// <param name="booleanLiteral">The <see cref="BooleanLiteral" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitBooleanLiteral(BooleanLiteral booleanLiteral)
        {
            Assert.ArgumentNotNull(booleanLiteral, () => booleanLiteral);

            var value = booleanLiteral.Value;
            return booleanLiteral.Update(value);
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="ExpressionStatement" />.
        /// </summary>
        /// <param name="expressionStatement">The <see cref="ExpressionStatement" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitExpressionStatement(ExpressionStatement expressionStatement)
        {
            Assert.ArgumentNotNull(expressionStatement, () => expressionStatement);

            var expression = (Expression)Visit(expressionStatement.Expression);
            return expressionStatement.Update(expression);
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="BlockStatement" />.
        /// </summary>
        /// <param name="blockStatement">The <see cref="BlockStatement" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitBlockStatement(BlockStatement blockStatement)
        {
            Assert.ArgumentNotNull(blockStatement, () => blockStatement);
            return blockStatement;
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="ReturnStatement" />.
        /// </summary>
        /// <param name="returnStatement">The <see cref="ReturnStatement" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitReturnStatement(ReturnStatement returnStatement)
        {
            Assert.ArgumentNotNull(returnStatement, () => returnStatement);

            var expression = (Expression)Visit(returnStatement.Expression);
            return returnStatement.Update(expression);
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="VoidTypeReference" />.
        /// </summary>
        /// <param name="voidTypeReference">The <see cref="VoidTypeReference" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitVoidTypeReference(VoidTypeReference voidTypeReference)
        {
            Assert.ArgumentNotNull(voidTypeReference, () => voidTypeReference);
            return voidTypeReference;
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="BooleanTypeReference" />.
        /// </summary>
        /// <param name="booleanTypeReference">The <see cref="BooleanTypeReference" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitBooleanTypeReference(BooleanTypeReference booleanTypeReference)
        {
            Assert.ArgumentNotNull(booleanTypeReference, () => booleanTypeReference);
            return booleanTypeReference;
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="IntegerTypeReference" />.
        /// </summary>
        /// <param name="integerTypeReference">The <see cref="IntegerTypeReference" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitIntegerTypeReference(IntegerTypeReference integerTypeReference)
        {
            Assert.ArgumentNotNull(integerTypeReference, () => integerTypeReference);
            return integerTypeReference;
        }

        /// <summary>
        ///     Rewrites a metamodel element of type <see cref="InterfaceTypeReference" />.
        /// </summary>
        /// <param name="interfaceTypeReference">The <see cref="InterfaceTypeReference" /> instance that should be rewritten.</param>
        public override MetamodelElement VisitInterfaceTypeReference(InterfaceTypeReference interfaceTypeReference)
        {
            Assert.ArgumentNotNull(interfaceTypeReference, () => interfaceTypeReference);

            var slot = interfaceTypeReference.Slot;
            return interfaceTypeReference.Update(slot);
        }
    }
}

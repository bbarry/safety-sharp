//------------------------------------------------------------------------------
// <auto-generated>
//     Generated by the 'Generator.fsx' script.
//     Wednesday, 30 April 2014, 07:36:10
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace SafetySharp.Modelchecking.Promela
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Modelchecking.Promela.Expressions;
    using SafetySharp.Modelchecking.Promela.Statements;

    internal partial class Proctype : Expression
    {
        /// <summary>
        ///     Gets if true then Proctype gets automatically executed at startup.
        /// </summary>
        public bool IsActive { get; private set; }

        /// <summary>
        ///     Gets the name of the Proctype.
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        ///     Gets a list of statements with the code of the Proctype.
        /// </summary>
        public ImmutableArray<Statement> Code { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="Proctype" /> class.
        /// </summary>
        /// <param name="isActive">If true then Proctype gets automatically executed at startup.</param>
        /// <param name="name">The name of the Proctype.</param>
        /// <param name="code">A list of statements with the code of the Proctype.</param>
        public Proctype(bool isActive, string name, ImmutableArray<Statement> code)
            : base()
        {
            Assert.ArgumentNotNull(name, () => name);

            Validate(isActive, name, code);
            IsActive = isActive;
            Name = name;
            Code = code;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="isActive">If true then Proctype gets automatically executed at startup.</param>
        /// <param name="name">The name of the Proctype.</param>
        /// <param name="code">A list of statements with the code of the Proctype.</param>
        partial void Validate(bool isActive, string name, ImmutableArray<Statement> code);

        /// <summary>
        ///     Creates a copy of the <see cref="Proctype" /> instance, changing only the value of the
        ///     <see cref="Proctype.IsActive" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="isActive">If true then Proctype gets automatically executed at startup.</param>
        public Proctype WithIsActive(bool isActive)
        {
            return Update(isActive, Name, Code);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="Proctype" /> instance, changing only the value of the
        ///     <see cref="Proctype.Name" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="name">The name of the Proctype.</param>
        public Proctype WithName(string name)
        {
            return Update(IsActive, name, Code);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="Proctype" /> instance, changing only the value of the
        ///     <see cref="Proctype.Code" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="code">A list of statements with the code of the Proctype.</param>
        public Proctype WithCode(ImmutableArray<Statement> code)
        {
            return Update(IsActive, Name, code);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="Proctype" /> instance, adding the given values to the
        ///     <see cref="Proctype.Code" /> collection; if <paramref name="code" /> is empty, 
        ///     no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="code">A list of statements with the code of the Proctype.</param>
        public Proctype AddCode(params Statement[] code)
        {
            return WithCode(Code.AddRange(code));
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="Proctype" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="isActive">If true then Proctype gets automatically executed at startup.</param>
        /// <param name="name">The name of the Proctype.</param>
        /// <param name="code">A list of statements with the code of the Proctype.</param>
        public Proctype Update(bool isActive, string name, ImmutableArray<Statement> code)
        {
            if (IsActive != isActive || Name != name || Code != code)
                return new Proctype(isActive, name, code);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitProctype(Proctype)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitProctype(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitProctype(Proctype)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitProctype(this);
        }
    }
}

namespace SafetySharp.Modelchecking.Promela.Expressions
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Modelchecking.Promela;
    using SafetySharp.Modelchecking.Promela.Statements;

    internal abstract partial class Expression : PromelaElement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="Expression" /> class.
        /// </summary>
        protected Expression()
            : base()
        {
        }
    }

    internal abstract partial class ConstExpression : Expression
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="ConstExpression" /> class.
        /// </summary>
        protected ConstExpression()
            : base()
        {
        }
    }

    internal partial class BooleanLiteral : ConstExpression
    {
        /// <summary>
        ///     Gets the Boolean value of the expression.
        /// </summary>
        public bool Value { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="BooleanLiteral" /> class.
        /// </summary>
        /// <param name="value">The Boolean value of the expression.</param>
        public BooleanLiteral(bool value)
            : base()
        {
            Validate(value);
            Value = value;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="value">The Boolean value of the expression.</param>
        partial void Validate(bool value);

        /// <summary>
        ///     Creates a copy of the <see cref="BooleanLiteral" /> instance, changing only the value of the
        ///     <see cref="BooleanLiteral.Value" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="value">The Boolean value of the expression.</param>
        public BooleanLiteral WithValue(bool value)
        {
            return Update(value);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="BooleanLiteral" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="value">The Boolean value of the expression.</param>
        public BooleanLiteral Update(bool value)
        {
            if (Value != value)
                return new BooleanLiteral(value);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitBooleanLiteral(BooleanLiteral)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitBooleanLiteral(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitBooleanLiteral(BooleanLiteral)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitBooleanLiteral(this);
        }
    }

    internal partial class NumberLiteral : ConstExpression
    {
        /// <summary>
        ///     Gets the Boolean value of the expression.
        /// </summary>
        public Int32 Value { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="NumberLiteral" /> class.
        /// </summary>
        /// <param name="value">The Boolean value of the expression.</param>
        public NumberLiteral(Int32 value)
            : base()
        {
            Validate(value);
            Value = value;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="value">The Boolean value of the expression.</param>
        partial void Validate(Int32 value);

        /// <summary>
        ///     Creates a copy of the <see cref="NumberLiteral" /> instance, changing only the value of the
        ///     <see cref="NumberLiteral.Value" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="value">The Boolean value of the expression.</param>
        public NumberLiteral WithValue(Int32 value)
        {
            return Update(value);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="NumberLiteral" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="value">The Boolean value of the expression.</param>
        public NumberLiteral Update(Int32 value)
        {
            if (Value != value)
                return new NumberLiteral(value);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitNumberLiteral(NumberLiteral)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitNumberLiteral(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitNumberLiteral(NumberLiteral)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitNumberLiteral(this);
        }
    }

    internal partial class SkipLiteral : ConstExpression
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="SkipLiteral" /> class.
        /// </summary>
        public SkipLiteral()
            : base()
        {
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitSkipLiteral(SkipLiteral)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitSkipLiteral(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitSkipLiteral(SkipLiteral)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitSkipLiteral(this);
        }
    }

    internal partial class BinaryExpression : Expression
    {
        /// <summary>
        ///     Gets the expression on the left-hand side of the binary operator.
        /// </summary>
        public Expression Left { get; private set; }

        /// <summary>
        ///     Gets the operator of the binary expression.
        /// </summary>
        public PromelaBinaryOperator Operator { get; private set; }

        /// <summary>
        ///     Gets the expression on the right-hand side of the binary operator.
        /// </summary>
        public Expression Right { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="BinaryExpression" /> class.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the binary operator.</param>
        /// <param name="operator">The operator of the binary expression.</param>
        /// <param name="right">The expression on the right-hand side of the binary operator.</param>
        public BinaryExpression(Expression left, PromelaBinaryOperator @operator, Expression right)
            : base()
        {
            Assert.ArgumentNotNull(left, () => left);
            Assert.ArgumentInRange(@operator, () => @operator);
            Assert.ArgumentNotNull(right, () => right);

            Validate(left, @operator, right);
            Left = left;
            Operator = @operator;
            Right = right;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the binary operator.</param>
        /// <param name="operator">The operator of the binary expression.</param>
        /// <param name="right">The expression on the right-hand side of the binary operator.</param>
        partial void Validate(Expression left, PromelaBinaryOperator @operator, Expression right);

        /// <summary>
        ///     Creates a copy of the <see cref="BinaryExpression" /> instance, changing only the value of the
        ///     <see cref="BinaryExpression.Left" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the binary operator.</param>
        public BinaryExpression WithLeft(Expression left)
        {
            return Update(left, Operator, Right);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="BinaryExpression" /> instance, changing only the value of the
        ///     <see cref="BinaryExpression.Operator" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="operator">The operator of the binary expression.</param>
        public BinaryExpression WithOperator(PromelaBinaryOperator @operator)
        {
            return Update(Left, @operator, Right);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="BinaryExpression" /> instance, changing only the value of the
        ///     <see cref="BinaryExpression.Right" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="right">The expression on the right-hand side of the binary operator.</param>
        public BinaryExpression WithRight(Expression right)
        {
            return Update(Left, Operator, right);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="BinaryExpression" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="left">The expression on the left-hand side of the binary operator.</param>
        /// <param name="operator">The operator of the binary expression.</param>
        /// <param name="right">The expression on the right-hand side of the binary operator.</param>
        public BinaryExpression Update(Expression left, PromelaBinaryOperator @operator, Expression right)
        {
            if (Left != left || Operator != @operator || Right != right)
                return new BinaryExpression(left, @operator, right);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitBinaryExpression(BinaryExpression)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitBinaryExpression(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitBinaryExpression(BinaryExpression)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitBinaryExpression(this);
        }
    }

    internal partial class UnaryExpression : Expression
    {
        /// <summary>
        ///     Gets the expression of the unary expression.
        /// </summary>
        public Expression Expression { get; private set; }

        /// <summary>
        ///     Gets the operator of the unary expression.
        /// </summary>
        public PromelaUnaryOperator Operator { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="UnaryExpression" /> class.
        /// </summary>
        /// <param name="expression">The expression of the unary expression.</param>
        /// <param name="operator">The operator of the unary expression.</param>
        public UnaryExpression(Expression expression, PromelaUnaryOperator @operator)
            : base()
        {
            Assert.ArgumentNotNull(expression, () => expression);
            Assert.ArgumentInRange(@operator, () => @operator);

            Validate(expression, @operator);
            Expression = expression;
            Operator = @operator;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="expression">The expression of the unary expression.</param>
        /// <param name="operator">The operator of the unary expression.</param>
        partial void Validate(Expression expression, PromelaUnaryOperator @operator);

        /// <summary>
        ///     Creates a copy of the <see cref="UnaryExpression" /> instance, changing only the value of the
        ///     <see cref="UnaryExpression.Expression" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="expression">The expression of the unary expression.</param>
        public UnaryExpression WithExpression(Expression expression)
        {
            return Update(expression, Operator);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="UnaryExpression" /> instance, changing only the value of the
        ///     <see cref="UnaryExpression.Operator" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="operator">The operator of the unary expression.</param>
        public UnaryExpression WithOperator(PromelaUnaryOperator @operator)
        {
            return Update(Expression, @operator);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="UnaryExpression" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="expression">The expression of the unary expression.</param>
        /// <param name="operator">The operator of the unary expression.</param>
        public UnaryExpression Update(Expression expression, PromelaUnaryOperator @operator)
        {
            if (Expression != expression || Operator != @operator)
                return new UnaryExpression(expression, @operator);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitUnaryExpression(UnaryExpression)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitUnaryExpression(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitUnaryExpression(UnaryExpression)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitUnaryExpression(this);
        }
    }

    internal partial class VariableReferenceExpression : Expression
    {
        /// <summary>
        ///     Gets the name of the identifier which references a variable.
        /// </summary>
        public string Identifier { get; private set; }

        /// <summary>
        ///     Gets identifier references an array. This is the index of a specific element in this array.
        /// </summary>
        public Expression Index { get; private set; }

        /// <summary>
        ///     Gets identifier (and maybe the Index) reference a struct. This references a specific member in this struct.
        /// </summary>
        public VariableReferenceExpression Member { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="VariableReferenceExpression" /> class.
        /// </summary>
        /// <param name="identifier">The name of the identifier which references a variable.</param>
        /// <param name="index">Identifier references an array. This is the index of a specific element in this array.</param>
        /// <param name="member">Identifier (and maybe the Index) reference a struct. This references a specific member in this struct.</param>
        public VariableReferenceExpression(string identifier, Expression index, VariableReferenceExpression member)
            : base()
        {
            Assert.ArgumentNotNull(identifier, () => identifier);

            Validate(identifier, index, member);
            Identifier = identifier;
            Index = index;
            Member = member;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="identifier">The name of the identifier which references a variable.</param>
        /// <param name="index">Identifier references an array. This is the index of a specific element in this array.</param>
        /// <param name="member">Identifier (and maybe the Index) reference a struct. This references a specific member in this struct.</param>
        partial void Validate(string identifier, Expression index, VariableReferenceExpression member);

        /// <summary>
        ///     Creates a copy of the <see cref="VariableReferenceExpression" /> instance, changing only the value of the
        ///     <see cref="VariableReferenceExpression.Identifier" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="identifier">The name of the identifier which references a variable.</param>
        public VariableReferenceExpression WithIdentifier(string identifier)
        {
            return Update(identifier, Index, Member);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="VariableReferenceExpression" /> instance, changing only the value of the
        ///     <see cref="VariableReferenceExpression.Index" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="index">Identifier references an array. This is the index of a specific element in this array.</param>
        public VariableReferenceExpression WithIndex(Expression index)
        {
            return Update(Identifier, index, Member);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="VariableReferenceExpression" /> instance, changing only the value of the
        ///     <see cref="VariableReferenceExpression.Member" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="member">Identifier (and maybe the Index) reference a struct. This references a specific member in this struct.</param>
        public VariableReferenceExpression WithMember(VariableReferenceExpression member)
        {
            return Update(Identifier, Index, member);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="VariableReferenceExpression" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="identifier">The name of the identifier which references a variable.</param>
        /// <param name="index">Identifier references an array. This is the index of a specific element in this array.</param>
        /// <param name="member">Identifier (and maybe the Index) reference a struct. This references a specific member in this struct.</param>
        public VariableReferenceExpression Update(string identifier, Expression index, VariableReferenceExpression member)
        {
            if (Identifier != identifier || Index != index || Member != member)
                return new VariableReferenceExpression(identifier, index, member);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitVariableReferenceExpression(VariableReferenceExpression)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitVariableReferenceExpression(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitVariableReferenceExpression(VariableReferenceExpression)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitVariableReferenceExpression(this);
        }
    }
}

namespace SafetySharp.Modelchecking.Promela.Statements
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Modelchecking.Promela;
    using SafetySharp.Modelchecking.Promela.Expressions;

    internal abstract partial class Statement : PromelaElement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="Statement" /> class.
        /// </summary>
        protected Statement()
            : base()
        {
        }
    }

    internal abstract partial class BlockStatement : Statement
    {
        /// <summary>
        ///     Gets a list of statements.
        /// </summary>
        public ImmutableArray<Statement> Statements { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="BlockStatement" /> class.
        /// </summary>
        /// <param name="statements">A list of statements.</param>
        protected BlockStatement(ImmutableArray<Statement> statements)
            : base()
        {
            Validate(statements);
            Statements = statements;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="statements">A list of statements.</param>
        partial void Validate(ImmutableArray<Statement> statements);
    }

    internal partial class SimpleBlockStatement : BlockStatement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="SimpleBlockStatement" /> class.
        /// </summary>
        /// <param name="statements">A list of statements.</param>
        public SimpleBlockStatement(ImmutableArray<Statement> statements)
            : base(statements)
        {
        }

        /// <summary>
        ///     Creates a copy of the <see cref="SimpleBlockStatement" /> instance, changing only the value of the
        ///     <see cref="SimpleBlockStatement.Statements" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="statements">A list of statements.</param>
        public SimpleBlockStatement WithStatements(ImmutableArray<Statement> statements)
        {
            return Update(statements);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="SimpleBlockStatement" /> instance, adding the given values to the
        ///     <see cref="SimpleBlockStatement.Statements" /> collection; if <paramref name="statements" /> is empty, 
        ///     no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="statements">A list of statements.</param>
        public SimpleBlockStatement AddStatements(params Statement[] statements)
        {
            return WithStatements(Statements.AddRange(statements));
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="SimpleBlockStatement" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="statements">A list of statements.</param>
        public SimpleBlockStatement Update(ImmutableArray<Statement> statements)
        {
            if (Statements != statements)
                return new SimpleBlockStatement(statements);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitSimpleBlockStatement(SimpleBlockStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitSimpleBlockStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitSimpleBlockStatement(SimpleBlockStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitSimpleBlockStatement(this);
        }
    }

    internal partial class AtomicBlockStatement : BlockStatement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="AtomicBlockStatement" /> class.
        /// </summary>
        /// <param name="statements">A list of statements.</param>
        public AtomicBlockStatement(ImmutableArray<Statement> statements)
            : base(statements)
        {
        }

        /// <summary>
        ///     Creates a copy of the <see cref="AtomicBlockStatement" /> instance, changing only the value of the
        ///     <see cref="AtomicBlockStatement.Statements" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="statements">A list of statements.</param>
        public AtomicBlockStatement WithStatements(ImmutableArray<Statement> statements)
        {
            return Update(statements);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="AtomicBlockStatement" /> instance, adding the given values to the
        ///     <see cref="AtomicBlockStatement.Statements" /> collection; if <paramref name="statements" /> is empty, 
        ///     no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="statements">A list of statements.</param>
        public AtomicBlockStatement AddStatements(params Statement[] statements)
        {
            return WithStatements(Statements.AddRange(statements));
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="AtomicBlockStatement" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="statements">A list of statements.</param>
        public AtomicBlockStatement Update(ImmutableArray<Statement> statements)
        {
            if (Statements != statements)
                return new AtomicBlockStatement(statements);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitAtomicBlockStatement(AtomicBlockStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitAtomicBlockStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitAtomicBlockStatement(AtomicBlockStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitAtomicBlockStatement(this);
        }
    }

    internal partial class DStepBlockStatement : BlockStatement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="DStepBlockStatement" /> class.
        /// </summary>
        /// <param name="statements">A list of statements.</param>
        public DStepBlockStatement(ImmutableArray<Statement> statements)
            : base(statements)
        {
        }

        /// <summary>
        ///     Creates a copy of the <see cref="DStepBlockStatement" /> instance, changing only the value of the
        ///     <see cref="DStepBlockStatement.Statements" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="statements">A list of statements.</param>
        public DStepBlockStatement WithStatements(ImmutableArray<Statement> statements)
        {
            return Update(statements);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="DStepBlockStatement" /> instance, adding the given values to the
        ///     <see cref="DStepBlockStatement.Statements" /> collection; if <paramref name="statements" /> is empty, 
        ///     no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="statements">A list of statements.</param>
        public DStepBlockStatement AddStatements(params Statement[] statements)
        {
            return WithStatements(Statements.AddRange(statements));
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="DStepBlockStatement" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="statements">A list of statements.</param>
        public DStepBlockStatement Update(ImmutableArray<Statement> statements)
        {
            if (Statements != statements)
                return new DStepBlockStatement(statements);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitDStepBlockStatement(DStepBlockStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitDStepBlockStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitDStepBlockStatement(DStepBlockStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitDStepBlockStatement(this);
        }
    }

    internal partial class ReturnStatement : Statement
    {
        /// <summary>
        ///     Gets the expression that should be evaluated and returned.
        /// </summary>
        public Expression Expression { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ReturnStatement" /> class.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated and returned.</param>
        public ReturnStatement(Expression expression)
            : base()
        {
            Assert.ArgumentNotNull(expression, () => expression);

            Validate(expression);
            Expression = expression;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated and returned.</param>
        partial void Validate(Expression expression);

        /// <summary>
        ///     Creates a copy of the <see cref="ReturnStatement" /> instance, changing only the value of the
        ///     <see cref="ReturnStatement.Expression" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated and returned.</param>
        public ReturnStatement WithExpression(Expression expression)
        {
            return Update(expression);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="ReturnStatement" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated and returned.</param>
        public ReturnStatement Update(Expression expression)
        {
            if (Expression != expression)
                return new ReturnStatement(expression);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitReturnStatement(ReturnStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitReturnStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitReturnStatement(ReturnStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitReturnStatement(this);
        }
    }

    internal partial class ExpressionStatement : Statement
    {
        /// <summary>
        ///     Gets the expression that should be evaluated.
        /// </summary>
        public Expression Expression { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ExpressionStatement" /> class.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated.</param>
        public ExpressionStatement(Expression expression)
            : base()
        {
            Assert.ArgumentNotNull(expression, () => expression);

            Validate(expression);
            Expression = expression;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated.</param>
        partial void Validate(Expression expression);

        /// <summary>
        ///     Creates a copy of the <see cref="ExpressionStatement" /> instance, changing only the value of the
        ///     <see cref="ExpressionStatement.Expression" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated.</param>
        public ExpressionStatement WithExpression(Expression expression)
        {
            return Update(expression);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="ExpressionStatement" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="expression">The expression that should be evaluated.</param>
        public ExpressionStatement Update(Expression expression)
        {
            if (Expression != expression)
                return new ExpressionStatement(expression);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitExpressionStatement(ExpressionStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitExpressionStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitExpressionStatement(ExpressionStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitExpressionStatement(this);
        }
    }

    internal partial class GuardedCommandRepetitionStatement : Statement
    {
        /// <summary>
        ///     Gets the clauses of the guarded command, one of which is chosen nondeterministically during execution if multiple guards hold.
        /// </summary>
        public ImmutableArray<GuardedCommandClause> Clauses { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="GuardedCommandRepetitionStatement" /> class.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chosen nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandRepetitionStatement(ImmutableArray<GuardedCommandClause> clauses)
            : base()
        {
            Validate(clauses);
            Clauses = clauses;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chosen nondeterministically during execution if multiple guards hold.</param>
        partial void Validate(ImmutableArray<GuardedCommandClause> clauses);

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandRepetitionStatement" /> instance, changing only the value of the
        ///     <see cref="GuardedCommandRepetitionStatement.Clauses" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chosen nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandRepetitionStatement WithClauses(ImmutableArray<GuardedCommandClause> clauses)
        {
            return Update(clauses);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandRepetitionStatement" /> instance, adding the given values to the
        ///     <see cref="GuardedCommandRepetitionStatement.Clauses" /> collection; if <paramref name="clauses" /> is empty, 
        ///     no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chosen nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandRepetitionStatement AddClauses(params GuardedCommandClause[] clauses)
        {
            return WithClauses(Clauses.AddRange(clauses));
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="GuardedCommandRepetitionStatement" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chosen nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandRepetitionStatement Update(ImmutableArray<GuardedCommandClause> clauses)
        {
            if (Clauses != clauses)
                return new GuardedCommandRepetitionStatement(clauses);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitGuardedCommandRepetitionStatement(GuardedCommandRepetitionStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitGuardedCommandRepetitionStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitGuardedCommandRepetitionStatement(GuardedCommandRepetitionStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitGuardedCommandRepetitionStatement(this);
        }
    }

    internal partial class GuardedCommandSelectionStatement : Statement
    {
        /// <summary>
        ///     Gets the clauses of the guarded command, one of which is chosen nondeterministically during execution if multiple guards hold.
        /// </summary>
        public ImmutableArray<GuardedCommandClause> Clauses { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="GuardedCommandSelectionStatement" /> class.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chosen nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandSelectionStatement(ImmutableArray<GuardedCommandClause> clauses)
            : base()
        {
            Validate(clauses);
            Clauses = clauses;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chosen nondeterministically during execution if multiple guards hold.</param>
        partial void Validate(ImmutableArray<GuardedCommandClause> clauses);

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandSelectionStatement" /> instance, changing only the value of the
        ///     <see cref="GuardedCommandSelectionStatement.Clauses" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chosen nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandSelectionStatement WithClauses(ImmutableArray<GuardedCommandClause> clauses)
        {
            return Update(clauses);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandSelectionStatement" /> instance, adding the given values to the
        ///     <see cref="GuardedCommandSelectionStatement.Clauses" /> collection; if <paramref name="clauses" /> is empty, 
        ///     no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chosen nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandSelectionStatement AddClauses(params GuardedCommandClause[] clauses)
        {
            return WithClauses(Clauses.AddRange(clauses));
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="GuardedCommandSelectionStatement" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="clauses">The clauses of the guarded command, one of which is chosen nondeterministically during execution if multiple guards hold.</param>
        public GuardedCommandSelectionStatement Update(ImmutableArray<GuardedCommandClause> clauses)
        {
            if (Clauses != clauses)
                return new GuardedCommandSelectionStatement(clauses);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitGuardedCommandSelectionStatement(GuardedCommandSelectionStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitGuardedCommandSelectionStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitGuardedCommandSelectionStatement(GuardedCommandSelectionStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitGuardedCommandSelectionStatement(this);
        }
    }

    internal abstract partial class GuardedCommandClause : PromelaElement
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="GuardedCommandClause" /> class.
        /// </summary>
        protected GuardedCommandClause()
            : base()
        {
        }
    }

    internal partial class GuardedCommandExpressionClause : GuardedCommandClause
    {
        /// <summary>
        ///     Gets the guard of the clause that determines whether the statement can be executed.
        /// </summary>
        public Expression Guard { get; private set; }

        /// <summary>
        ///     Gets the statement of the clause that can only be executed if the guard holds.
        /// </summary>
        public Statement Statement { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="GuardedCommandExpressionClause" /> class.
        /// </summary>
        /// <param name="guard">The guard of the clause that determines whether the statement can be executed.</param>
        /// <param name="statement">The statement of the clause that can only be executed if the guard holds.</param>
        public GuardedCommandExpressionClause(Expression guard, Statement statement)
            : base()
        {
            Assert.ArgumentNotNull(guard, () => guard);
            Assert.ArgumentNotNull(statement, () => statement);

            Validate(guard, statement);
            Guard = guard;
            Statement = statement;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="guard">The guard of the clause that determines whether the statement can be executed.</param>
        /// <param name="statement">The statement of the clause that can only be executed if the guard holds.</param>
        partial void Validate(Expression guard, Statement statement);

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandExpressionClause" /> instance, changing only the value of the
        ///     <see cref="GuardedCommandExpressionClause.Guard" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="guard">The guard of the clause that determines whether the statement can be executed.</param>
        public GuardedCommandExpressionClause WithGuard(Expression guard)
        {
            return Update(guard, Statement);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandExpressionClause" /> instance, changing only the value of the
        ///     <see cref="GuardedCommandExpressionClause.Statement" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="statement">The statement of the clause that can only be executed if the guard holds.</param>
        public GuardedCommandExpressionClause WithStatement(Statement statement)
        {
            return Update(Guard, statement);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="GuardedCommandExpressionClause" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="guard">The guard of the clause that determines whether the statement can be executed.</param>
        /// <param name="statement">The statement of the clause that can only be executed if the guard holds.</param>
        public GuardedCommandExpressionClause Update(Expression guard, Statement statement)
        {
            if (Guard != guard || Statement != statement)
                return new GuardedCommandExpressionClause(guard, statement);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitGuardedCommandExpressionClause(GuardedCommandExpressionClause)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitGuardedCommandExpressionClause(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitGuardedCommandExpressionClause(GuardedCommandExpressionClause)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitGuardedCommandExpressionClause(this);
        }
    }

    internal partial class GuardedCommandElseClause : GuardedCommandClause
    {
        /// <summary>
        ///     Gets the statement of the clause that can only be executed if no other clause holds.
        /// </summary>
        public Statement Statement { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="GuardedCommandElseClause" /> class.
        /// </summary>
        /// <param name="statement">The statement of the clause that can only be executed if no other clause holds.</param>
        public GuardedCommandElseClause(Statement statement)
            : base()
        {
            Assert.ArgumentNotNull(statement, () => statement);

            Validate(statement);
            Statement = statement;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="statement">The statement of the clause that can only be executed if no other clause holds.</param>
        partial void Validate(Statement statement);

        /// <summary>
        ///     Creates a copy of the <see cref="GuardedCommandElseClause" /> instance, changing only the value of the
        ///     <see cref="GuardedCommandElseClause.Statement" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="statement">The statement of the clause that can only be executed if no other clause holds.</param>
        public GuardedCommandElseClause WithStatement(Statement statement)
        {
            return Update(statement);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="GuardedCommandElseClause" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="statement">The statement of the clause that can only be executed if no other clause holds.</param>
        public GuardedCommandElseClause Update(Statement statement)
        {
            if (Statement != statement)
                return new GuardedCommandElseClause(statement);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitGuardedCommandElseClause(GuardedCommandElseClause)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitGuardedCommandElseClause(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitGuardedCommandElseClause(GuardedCommandElseClause)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitGuardedCommandElseClause(this);
        }
    }

    internal partial class AssignmentStatement : Statement
    {
        /// <summary>
        ///     Gets the reference to the variable on the left-hand side of the assignment operator.
        /// </summary>
        public VariableReferenceExpression Left { get; private set; }

        /// <summary>
        ///     Gets the expression on the right-hand side of the assignment operator.
        /// </summary>
        public Expression Right { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="AssignmentStatement" /> class.
        /// </summary>
        /// <param name="left">The reference to the variable on the left-hand side of the assignment operator.</param>
        /// <param name="right">The expression on the right-hand side of the assignment operator.</param>
        public AssignmentStatement(VariableReferenceExpression left, Expression right)
            : base()
        {
            Assert.ArgumentNotNull(left, () => left);
            Assert.ArgumentNotNull(right, () => right);

            Validate(left, right);
            Left = left;
            Right = right;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="left">The reference to the variable on the left-hand side of the assignment operator.</param>
        /// <param name="right">The expression on the right-hand side of the assignment operator.</param>
        partial void Validate(VariableReferenceExpression left, Expression right);

        /// <summary>
        ///     Creates a copy of the <see cref="AssignmentStatement" /> instance, changing only the value of the
        ///     <see cref="AssignmentStatement.Left" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="left">The reference to the variable on the left-hand side of the assignment operator.</param>
        public AssignmentStatement WithLeft(VariableReferenceExpression left)
        {
            return Update(left, Right);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="AssignmentStatement" /> instance, changing only the value of the
        ///     <see cref="AssignmentStatement.Right" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="right">The expression on the right-hand side of the assignment operator.</param>
        public AssignmentStatement WithRight(Expression right)
        {
            return Update(Left, right);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="AssignmentStatement" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="left">The reference to the variable on the left-hand side of the assignment operator.</param>
        /// <param name="right">The expression on the right-hand side of the assignment operator.</param>
        public AssignmentStatement Update(VariableReferenceExpression left, Expression right)
        {
            if (Left != left || Right != right)
                return new AssignmentStatement(left, right);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitAssignmentStatement(AssignmentStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitAssignmentStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitAssignmentStatement(AssignmentStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitAssignmentStatement(this);
        }
    }

    internal partial class DeclarationStatement : Statement
    {
        /// <summary>
        ///     Gets the type of the declared variable.
        /// </summary>
        public PromelaTypeName Type { get; private set; }

        /// <summary>
        ///     Gets the name of the declared variable.
        /// </summary>
        public string Identifier { get; private set; }

        /// <summary>
        ///     Gets the size of the array, if declared variable is an array. Otherwise 0.
        /// </summary>
        public Int32 ArraySize { get; private set; }

        /// <summary>
        ///     Gets an expression, which determines the initial value of the declared variable.
        /// </summary>
        public Expression InitialValue { get; private set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="DeclarationStatement" /> class.
        /// </summary>
        /// <param name="type">The type of the declared variable.</param>
        /// <param name="identifier">The name of the declared variable.</param>
        /// <param name="arraySize">The size of the array, if declared variable is an array. Otherwise 0.</param>
        /// <param name="initialValue">An expression, which determines the initial value of the declared variable.</param>
        public DeclarationStatement(PromelaTypeName type, string identifier, Int32 arraySize, Expression initialValue)
            : base()
        {
            Assert.ArgumentNotNull(identifier, () => identifier);

            Validate(type, identifier, arraySize, initialValue);
            Type = type;
            Identifier = identifier;
            ArraySize = arraySize;
            InitialValue = initialValue;
        }

        /// <summary>
        ///     Validates all of the given property values.
        /// </summary>
        /// <param name="type">The type of the declared variable.</param>
        /// <param name="identifier">The name of the declared variable.</param>
        /// <param name="arraySize">The size of the array, if declared variable is an array. Otherwise 0.</param>
        /// <param name="initialValue">An expression, which determines the initial value of the declared variable.</param>
        partial void Validate(PromelaTypeName type, string identifier, Int32 arraySize, Expression initialValue);

        /// <summary>
        ///     Creates a copy of the <see cref="DeclarationStatement" /> instance, changing only the value of the
        ///     <see cref="DeclarationStatement.Type" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="type">The type of the declared variable.</param>
        public DeclarationStatement WithType(PromelaTypeName type)
        {
            return Update(type, Identifier, ArraySize, InitialValue);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="DeclarationStatement" /> instance, changing only the value of the
        ///     <see cref="DeclarationStatement.Identifier" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="identifier">The name of the declared variable.</param>
        public DeclarationStatement WithIdentifier(string identifier)
        {
            return Update(Type, identifier, ArraySize, InitialValue);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="DeclarationStatement" /> instance, changing only the value of the
        ///     <see cref="DeclarationStatement.ArraySize" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="arraySize">The size of the array, if declared variable is an array. Otherwise 0.</param>
        public DeclarationStatement WithArraySize(Int32 arraySize)
        {
            return Update(Type, Identifier, arraySize, InitialValue);
        }

        /// <summary>
        ///     Creates a copy of the <see cref="DeclarationStatement" /> instance, changing only the value of the
        ///     <see cref="DeclarationStatement.InitialValue" /> property; if the property value has not changed, 
        ///     no copy is made and the original object is returned.
        /// </summary>
        /// <param name="initialValue">An expression, which determines the initial value of the declared variable.</param>
        public DeclarationStatement WithInitialValue(Expression initialValue)
        {
            return Update(Type, Identifier, ArraySize, initialValue);
        }

        /// <summary>
        ///     Creates a new instance of the <see cref="DeclarationStatement" /> class if any of the property values
        ///     have changed; if none have changed, no copy is made and the original instance is returned.
        /// </summary>
        /// <param name="type">The type of the declared variable.</param>
        /// <param name="identifier">The name of the declared variable.</param>
        /// <param name="arraySize">The size of the array, if declared variable is an array. Otherwise 0.</param>
        /// <param name="initialValue">An expression, which determines the initial value of the declared variable.</param>
        public DeclarationStatement Update(PromelaTypeName type, string identifier, Int32 arraySize, Expression initialValue)
        {
            if (Type != type || Identifier != identifier || ArraySize != arraySize || InitialValue != initialValue)
                return new DeclarationStatement(type, identifier, arraySize, initialValue);

            return this;
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor.VisitDeclarationStatement(DeclarationStatement)" /> method.
        /// </summary>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override void Accept(PromelaVisitor visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            visitor.VisitDeclarationStatement(this);
        }

        /// <summary>
        ///     Implements the visitor pattern, calling <paramref name="visitor" />'s
        ///     <see cref="PromelaVisitor{TResult}.VisitDeclarationStatement(DeclarationStatement)" /> method.
        /// </summary>
        /// <typeparam name="TResult">The type of the value returned by <paramref name="visitor" />.</typeparam>
        /// <param name="visitor">The visitor the type-specific visit method should be invoked on.</param>
        public override TResult Accept<TResult>(PromelaVisitor<TResult> visitor)
        {
            Assert.ArgumentNotNull(visitor, () => visitor);
            return visitor.VisitDeclarationStatement(this);
        }
    }
}

namespace SafetySharp.Modelchecking.Promela
{
    using System;
    using System.Collections.Immutable;

    using SafetySharp.Utilities;
    using SafetySharp.Modelchecking.Promela.Expressions;
    using SafetySharp.Modelchecking.Promela.Statements;

    internal abstract partial class PromelaVisitor
    {
        /// <summary>
        ///     Visits an element of type <see cref="Proctype" />.
        /// </summary>
        /// <param name="proctype">The <see cref="Proctype" /> instance that should be visited.</param>
        public virtual void VisitProctype(Proctype proctype)
        {
            Assert.ArgumentNotNull(proctype, () => proctype);
        }

        /// <summary>
        ///     Visits an element of type <see cref="BooleanLiteral" />.
        /// </summary>
        /// <param name="booleanLiteral">The <see cref="BooleanLiteral" /> instance that should be visited.</param>
        public virtual void VisitBooleanLiteral(BooleanLiteral booleanLiteral)
        {
            Assert.ArgumentNotNull(booleanLiteral, () => booleanLiteral);
        }

        /// <summary>
        ///     Visits an element of type <see cref="NumberLiteral" />.
        /// </summary>
        /// <param name="numberLiteral">The <see cref="NumberLiteral" /> instance that should be visited.</param>
        public virtual void VisitNumberLiteral(NumberLiteral numberLiteral)
        {
            Assert.ArgumentNotNull(numberLiteral, () => numberLiteral);
        }

        /// <summary>
        ///     Visits an element of type <see cref="SkipLiteral" />.
        /// </summary>
        /// <param name="skipLiteral">The <see cref="SkipLiteral" /> instance that should be visited.</param>
        public virtual void VisitSkipLiteral(SkipLiteral skipLiteral)
        {
            Assert.ArgumentNotNull(skipLiteral, () => skipLiteral);
        }

        /// <summary>
        ///     Visits an element of type <see cref="BinaryExpression" />.
        /// </summary>
        /// <param name="binaryExpression">The <see cref="BinaryExpression" /> instance that should be visited.</param>
        public virtual void VisitBinaryExpression(BinaryExpression binaryExpression)
        {
            Assert.ArgumentNotNull(binaryExpression, () => binaryExpression);
        }

        /// <summary>
        ///     Visits an element of type <see cref="UnaryExpression" />.
        /// </summary>
        /// <param name="unaryExpression">The <see cref="UnaryExpression" /> instance that should be visited.</param>
        public virtual void VisitUnaryExpression(UnaryExpression unaryExpression)
        {
            Assert.ArgumentNotNull(unaryExpression, () => unaryExpression);
        }

        /// <summary>
        ///     Visits an element of type <see cref="VariableReferenceExpression" />.
        /// </summary>
        /// <param name="variableReferenceExpression">The <see cref="VariableReferenceExpression" /> instance that should be visited.</param>
        public virtual void VisitVariableReferenceExpression(VariableReferenceExpression variableReferenceExpression)
        {
            Assert.ArgumentNotNull(variableReferenceExpression, () => variableReferenceExpression);
        }

        /// <summary>
        ///     Visits an element of type <see cref="SimpleBlockStatement" />.
        /// </summary>
        /// <param name="simpleBlockStatement">The <see cref="SimpleBlockStatement" /> instance that should be visited.</param>
        public virtual void VisitSimpleBlockStatement(SimpleBlockStatement simpleBlockStatement)
        {
            Assert.ArgumentNotNull(simpleBlockStatement, () => simpleBlockStatement);
        }

        /// <summary>
        ///     Visits an element of type <see cref="AtomicBlockStatement" />.
        /// </summary>
        /// <param name="atomicBlockStatement">The <see cref="AtomicBlockStatement" /> instance that should be visited.</param>
        public virtual void VisitAtomicBlockStatement(AtomicBlockStatement atomicBlockStatement)
        {
            Assert.ArgumentNotNull(atomicBlockStatement, () => atomicBlockStatement);
        }

        /// <summary>
        ///     Visits an element of type <see cref="DStepBlockStatement" />.
        /// </summary>
        /// <param name="dStepBlockStatement">The <see cref="DStepBlockStatement" /> instance that should be visited.</param>
        public virtual void VisitDStepBlockStatement(DStepBlockStatement dStepBlockStatement)
        {
            Assert.ArgumentNotNull(dStepBlockStatement, () => dStepBlockStatement);
        }

        /// <summary>
        ///     Visits an element of type <see cref="ReturnStatement" />.
        /// </summary>
        /// <param name="returnStatement">The <see cref="ReturnStatement" /> instance that should be visited.</param>
        public virtual void VisitReturnStatement(ReturnStatement returnStatement)
        {
            Assert.ArgumentNotNull(returnStatement, () => returnStatement);
        }

        /// <summary>
        ///     Visits an element of type <see cref="ExpressionStatement" />.
        /// </summary>
        /// <param name="expressionStatement">The <see cref="ExpressionStatement" /> instance that should be visited.</param>
        public virtual void VisitExpressionStatement(ExpressionStatement expressionStatement)
        {
            Assert.ArgumentNotNull(expressionStatement, () => expressionStatement);
        }

        /// <summary>
        ///     Visits an element of type <see cref="GuardedCommandRepetitionStatement" />.
        /// </summary>
        /// <param name="guardedCommandRepetitionStatement">The <see cref="GuardedCommandRepetitionStatement" /> instance that should be visited.</param>
        public virtual void VisitGuardedCommandRepetitionStatement(GuardedCommandRepetitionStatement guardedCommandRepetitionStatement)
        {
            Assert.ArgumentNotNull(guardedCommandRepetitionStatement, () => guardedCommandRepetitionStatement);
        }

        /// <summary>
        ///     Visits an element of type <see cref="GuardedCommandSelectionStatement" />.
        /// </summary>
        /// <param name="guardedCommandSelectionStatement">The <see cref="GuardedCommandSelectionStatement" /> instance that should be visited.</param>
        public virtual void VisitGuardedCommandSelectionStatement(GuardedCommandSelectionStatement guardedCommandSelectionStatement)
        {
            Assert.ArgumentNotNull(guardedCommandSelectionStatement, () => guardedCommandSelectionStatement);
        }

        /// <summary>
        ///     Visits an element of type <see cref="GuardedCommandExpressionClause" />.
        /// </summary>
        /// <param name="guardedCommandExpressionClause">The <see cref="GuardedCommandExpressionClause" /> instance that should be visited.</param>
        public virtual void VisitGuardedCommandExpressionClause(GuardedCommandExpressionClause guardedCommandExpressionClause)
        {
            Assert.ArgumentNotNull(guardedCommandExpressionClause, () => guardedCommandExpressionClause);
        }

        /// <summary>
        ///     Visits an element of type <see cref="GuardedCommandElseClause" />.
        /// </summary>
        /// <param name="guardedCommandElseClause">The <see cref="GuardedCommandElseClause" /> instance that should be visited.</param>
        public virtual void VisitGuardedCommandElseClause(GuardedCommandElseClause guardedCommandElseClause)
        {
            Assert.ArgumentNotNull(guardedCommandElseClause, () => guardedCommandElseClause);
        }

        /// <summary>
        ///     Visits an element of type <see cref="AssignmentStatement" />.
        /// </summary>
        /// <param name="assignmentStatement">The <see cref="AssignmentStatement" /> instance that should be visited.</param>
        public virtual void VisitAssignmentStatement(AssignmentStatement assignmentStatement)
        {
            Assert.ArgumentNotNull(assignmentStatement, () => assignmentStatement);
        }

        /// <summary>
        ///     Visits an element of type <see cref="DeclarationStatement" />.
        /// </summary>
        /// <param name="declarationStatement">The <see cref="DeclarationStatement" /> instance that should be visited.</param>
        public virtual void VisitDeclarationStatement(DeclarationStatement declarationStatement)
        {
            Assert.ArgumentNotNull(declarationStatement, () => declarationStatement);
        }
    }

    internal abstract partial class PromelaVisitor<TResult>
    {
        /// <summary>
        ///     Visits an element of type <see cref="Proctype" />.
        /// </summary>
        /// <param name="proctype">The <see cref="Proctype" /> instance that should be visited.</param>
        public virtual TResult VisitProctype(Proctype proctype)
        {
            Assert.ArgumentNotNull(proctype, () => proctype);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="BooleanLiteral" />.
        /// </summary>
        /// <param name="booleanLiteral">The <see cref="BooleanLiteral" /> instance that should be visited.</param>
        public virtual TResult VisitBooleanLiteral(BooleanLiteral booleanLiteral)
        {
            Assert.ArgumentNotNull(booleanLiteral, () => booleanLiteral);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="NumberLiteral" />.
        /// </summary>
        /// <param name="numberLiteral">The <see cref="NumberLiteral" /> instance that should be visited.</param>
        public virtual TResult VisitNumberLiteral(NumberLiteral numberLiteral)
        {
            Assert.ArgumentNotNull(numberLiteral, () => numberLiteral);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="SkipLiteral" />.
        /// </summary>
        /// <param name="skipLiteral">The <see cref="SkipLiteral" /> instance that should be visited.</param>
        public virtual TResult VisitSkipLiteral(SkipLiteral skipLiteral)
        {
            Assert.ArgumentNotNull(skipLiteral, () => skipLiteral);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="BinaryExpression" />.
        /// </summary>
        /// <param name="binaryExpression">The <see cref="BinaryExpression" /> instance that should be visited.</param>
        public virtual TResult VisitBinaryExpression(BinaryExpression binaryExpression)
        {
            Assert.ArgumentNotNull(binaryExpression, () => binaryExpression);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="UnaryExpression" />.
        /// </summary>
        /// <param name="unaryExpression">The <see cref="UnaryExpression" /> instance that should be visited.</param>
        public virtual TResult VisitUnaryExpression(UnaryExpression unaryExpression)
        {
            Assert.ArgumentNotNull(unaryExpression, () => unaryExpression);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="VariableReferenceExpression" />.
        /// </summary>
        /// <param name="variableReferenceExpression">The <see cref="VariableReferenceExpression" /> instance that should be visited.</param>
        public virtual TResult VisitVariableReferenceExpression(VariableReferenceExpression variableReferenceExpression)
        {
            Assert.ArgumentNotNull(variableReferenceExpression, () => variableReferenceExpression);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="SimpleBlockStatement" />.
        /// </summary>
        /// <param name="simpleBlockStatement">The <see cref="SimpleBlockStatement" /> instance that should be visited.</param>
        public virtual TResult VisitSimpleBlockStatement(SimpleBlockStatement simpleBlockStatement)
        {
            Assert.ArgumentNotNull(simpleBlockStatement, () => simpleBlockStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="AtomicBlockStatement" />.
        /// </summary>
        /// <param name="atomicBlockStatement">The <see cref="AtomicBlockStatement" /> instance that should be visited.</param>
        public virtual TResult VisitAtomicBlockStatement(AtomicBlockStatement atomicBlockStatement)
        {
            Assert.ArgumentNotNull(atomicBlockStatement, () => atomicBlockStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="DStepBlockStatement" />.
        /// </summary>
        /// <param name="dStepBlockStatement">The <see cref="DStepBlockStatement" /> instance that should be visited.</param>
        public virtual TResult VisitDStepBlockStatement(DStepBlockStatement dStepBlockStatement)
        {
            Assert.ArgumentNotNull(dStepBlockStatement, () => dStepBlockStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="ReturnStatement" />.
        /// </summary>
        /// <param name="returnStatement">The <see cref="ReturnStatement" /> instance that should be visited.</param>
        public virtual TResult VisitReturnStatement(ReturnStatement returnStatement)
        {
            Assert.ArgumentNotNull(returnStatement, () => returnStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="ExpressionStatement" />.
        /// </summary>
        /// <param name="expressionStatement">The <see cref="ExpressionStatement" /> instance that should be visited.</param>
        public virtual TResult VisitExpressionStatement(ExpressionStatement expressionStatement)
        {
            Assert.ArgumentNotNull(expressionStatement, () => expressionStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="GuardedCommandRepetitionStatement" />.
        /// </summary>
        /// <param name="guardedCommandRepetitionStatement">The <see cref="GuardedCommandRepetitionStatement" /> instance that should be visited.</param>
        public virtual TResult VisitGuardedCommandRepetitionStatement(GuardedCommandRepetitionStatement guardedCommandRepetitionStatement)
        {
            Assert.ArgumentNotNull(guardedCommandRepetitionStatement, () => guardedCommandRepetitionStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="GuardedCommandSelectionStatement" />.
        /// </summary>
        /// <param name="guardedCommandSelectionStatement">The <see cref="GuardedCommandSelectionStatement" /> instance that should be visited.</param>
        public virtual TResult VisitGuardedCommandSelectionStatement(GuardedCommandSelectionStatement guardedCommandSelectionStatement)
        {
            Assert.ArgumentNotNull(guardedCommandSelectionStatement, () => guardedCommandSelectionStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="GuardedCommandExpressionClause" />.
        /// </summary>
        /// <param name="guardedCommandExpressionClause">The <see cref="GuardedCommandExpressionClause" /> instance that should be visited.</param>
        public virtual TResult VisitGuardedCommandExpressionClause(GuardedCommandExpressionClause guardedCommandExpressionClause)
        {
            Assert.ArgumentNotNull(guardedCommandExpressionClause, () => guardedCommandExpressionClause);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="GuardedCommandElseClause" />.
        /// </summary>
        /// <param name="guardedCommandElseClause">The <see cref="GuardedCommandElseClause" /> instance that should be visited.</param>
        public virtual TResult VisitGuardedCommandElseClause(GuardedCommandElseClause guardedCommandElseClause)
        {
            Assert.ArgumentNotNull(guardedCommandElseClause, () => guardedCommandElseClause);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="AssignmentStatement" />.
        /// </summary>
        /// <param name="assignmentStatement">The <see cref="AssignmentStatement" /> instance that should be visited.</param>
        public virtual TResult VisitAssignmentStatement(AssignmentStatement assignmentStatement)
        {
            Assert.ArgumentNotNull(assignmentStatement, () => assignmentStatement);
            return default(TResult);
        }

        /// <summary>
        ///     Visits an element of type <see cref="DeclarationStatement" />.
        /// </summary>
        /// <param name="declarationStatement">The <see cref="DeclarationStatement" /> instance that should be visited.</param>
        public virtual TResult VisitDeclarationStatement(DeclarationStatement declarationStatement)
        {
            Assert.ArgumentNotNull(declarationStatement, () => declarationStatement);
            return default(TResult);
        }
    }

    internal abstract partial class PromelaRewriter : PromelaVisitor<PromelaElement>
    {
        /// <summary>
        ///     Rewrites an element of type <see cref="Proctype" />.
        /// </summary>
        /// <param name="proctype">The <see cref="Proctype" /> instance that should be rewritten.</param>
        public override PromelaElement VisitProctype(Proctype proctype)
        {
            Assert.ArgumentNotNull(proctype, () => proctype);

            var isActive = proctype.IsActive;
            var name = proctype.Name;
            var code = Visit(proctype.Code);
            return proctype.Update(isActive, name, code);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="BooleanLiteral" />.
        /// </summary>
        /// <param name="booleanLiteral">The <see cref="BooleanLiteral" /> instance that should be rewritten.</param>
        public override PromelaElement VisitBooleanLiteral(BooleanLiteral booleanLiteral)
        {
            Assert.ArgumentNotNull(booleanLiteral, () => booleanLiteral);

            var value = booleanLiteral.Value;
            return booleanLiteral.Update(value);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="NumberLiteral" />.
        /// </summary>
        /// <param name="numberLiteral">The <see cref="NumberLiteral" /> instance that should be rewritten.</param>
        public override PromelaElement VisitNumberLiteral(NumberLiteral numberLiteral)
        {
            Assert.ArgumentNotNull(numberLiteral, () => numberLiteral);

            var value = numberLiteral.Value;
            return numberLiteral.Update(value);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="SkipLiteral" />.
        /// </summary>
        /// <param name="skipLiteral">The <see cref="SkipLiteral" /> instance that should be rewritten.</param>
        public override PromelaElement VisitSkipLiteral(SkipLiteral skipLiteral)
        {
            Assert.ArgumentNotNull(skipLiteral, () => skipLiteral);
            return skipLiteral;
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="BinaryExpression" />.
        /// </summary>
        /// <param name="binaryExpression">The <see cref="BinaryExpression" /> instance that should be rewritten.</param>
        public override PromelaElement VisitBinaryExpression(BinaryExpression binaryExpression)
        {
            Assert.ArgumentNotNull(binaryExpression, () => binaryExpression);

            var left = (Expression)Visit(binaryExpression.Left);
            var @operator = binaryExpression.Operator;
            var right = (Expression)Visit(binaryExpression.Right);
            return binaryExpression.Update(left, @operator, right);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="UnaryExpression" />.
        /// </summary>
        /// <param name="unaryExpression">The <see cref="UnaryExpression" /> instance that should be rewritten.</param>
        public override PromelaElement VisitUnaryExpression(UnaryExpression unaryExpression)
        {
            Assert.ArgumentNotNull(unaryExpression, () => unaryExpression);

            var expression = (Expression)Visit(unaryExpression.Expression);
            var @operator = unaryExpression.Operator;
            return unaryExpression.Update(expression, @operator);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="VariableReferenceExpression" />.
        /// </summary>
        /// <param name="variableReferenceExpression">The <see cref="VariableReferenceExpression" /> instance that should be rewritten.</param>
        public override PromelaElement VisitVariableReferenceExpression(VariableReferenceExpression variableReferenceExpression)
        {
            Assert.ArgumentNotNull(variableReferenceExpression, () => variableReferenceExpression);

            var identifier = variableReferenceExpression.Identifier;
            var index = (Expression)Visit(variableReferenceExpression.Index);
            var member = (VariableReferenceExpression)Visit(variableReferenceExpression.Member);
            return variableReferenceExpression.Update(identifier, index, member);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="SimpleBlockStatement" />.
        /// </summary>
        /// <param name="simpleBlockStatement">The <see cref="SimpleBlockStatement" /> instance that should be rewritten.</param>
        public override PromelaElement VisitSimpleBlockStatement(SimpleBlockStatement simpleBlockStatement)
        {
            Assert.ArgumentNotNull(simpleBlockStatement, () => simpleBlockStatement);

            var statements = Visit(simpleBlockStatement.Statements);
            return simpleBlockStatement.Update(statements);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="AtomicBlockStatement" />.
        /// </summary>
        /// <param name="atomicBlockStatement">The <see cref="AtomicBlockStatement" /> instance that should be rewritten.</param>
        public override PromelaElement VisitAtomicBlockStatement(AtomicBlockStatement atomicBlockStatement)
        {
            Assert.ArgumentNotNull(atomicBlockStatement, () => atomicBlockStatement);

            var statements = Visit(atomicBlockStatement.Statements);
            return atomicBlockStatement.Update(statements);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="DStepBlockStatement" />.
        /// </summary>
        /// <param name="dStepBlockStatement">The <see cref="DStepBlockStatement" /> instance that should be rewritten.</param>
        public override PromelaElement VisitDStepBlockStatement(DStepBlockStatement dStepBlockStatement)
        {
            Assert.ArgumentNotNull(dStepBlockStatement, () => dStepBlockStatement);

            var statements = Visit(dStepBlockStatement.Statements);
            return dStepBlockStatement.Update(statements);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="ReturnStatement" />.
        /// </summary>
        /// <param name="returnStatement">The <see cref="ReturnStatement" /> instance that should be rewritten.</param>
        public override PromelaElement VisitReturnStatement(ReturnStatement returnStatement)
        {
            Assert.ArgumentNotNull(returnStatement, () => returnStatement);

            var expression = (Expression)Visit(returnStatement.Expression);
            return returnStatement.Update(expression);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="ExpressionStatement" />.
        /// </summary>
        /// <param name="expressionStatement">The <see cref="ExpressionStatement" /> instance that should be rewritten.</param>
        public override PromelaElement VisitExpressionStatement(ExpressionStatement expressionStatement)
        {
            Assert.ArgumentNotNull(expressionStatement, () => expressionStatement);

            var expression = (Expression)Visit(expressionStatement.Expression);
            return expressionStatement.Update(expression);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="GuardedCommandRepetitionStatement" />.
        /// </summary>
        /// <param name="guardedCommandRepetitionStatement">The <see cref="GuardedCommandRepetitionStatement" /> instance that should be rewritten.</param>
        public override PromelaElement VisitGuardedCommandRepetitionStatement(GuardedCommandRepetitionStatement guardedCommandRepetitionStatement)
        {
            Assert.ArgumentNotNull(guardedCommandRepetitionStatement, () => guardedCommandRepetitionStatement);

            var clauses = Visit(guardedCommandRepetitionStatement.Clauses);
            return guardedCommandRepetitionStatement.Update(clauses);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="GuardedCommandSelectionStatement" />.
        /// </summary>
        /// <param name="guardedCommandSelectionStatement">The <see cref="GuardedCommandSelectionStatement" /> instance that should be rewritten.</param>
        public override PromelaElement VisitGuardedCommandSelectionStatement(GuardedCommandSelectionStatement guardedCommandSelectionStatement)
        {
            Assert.ArgumentNotNull(guardedCommandSelectionStatement, () => guardedCommandSelectionStatement);

            var clauses = Visit(guardedCommandSelectionStatement.Clauses);
            return guardedCommandSelectionStatement.Update(clauses);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="GuardedCommandExpressionClause" />.
        /// </summary>
        /// <param name="guardedCommandExpressionClause">The <see cref="GuardedCommandExpressionClause" /> instance that should be rewritten.</param>
        public override PromelaElement VisitGuardedCommandExpressionClause(GuardedCommandExpressionClause guardedCommandExpressionClause)
        {
            Assert.ArgumentNotNull(guardedCommandExpressionClause, () => guardedCommandExpressionClause);

            var guard = (Expression)Visit(guardedCommandExpressionClause.Guard);
            var statement = (Statement)Visit(guardedCommandExpressionClause.Statement);
            return guardedCommandExpressionClause.Update(guard, statement);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="GuardedCommandElseClause" />.
        /// </summary>
        /// <param name="guardedCommandElseClause">The <see cref="GuardedCommandElseClause" /> instance that should be rewritten.</param>
        public override PromelaElement VisitGuardedCommandElseClause(GuardedCommandElseClause guardedCommandElseClause)
        {
            Assert.ArgumentNotNull(guardedCommandElseClause, () => guardedCommandElseClause);

            var statement = (Statement)Visit(guardedCommandElseClause.Statement);
            return guardedCommandElseClause.Update(statement);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="AssignmentStatement" />.
        /// </summary>
        /// <param name="assignmentStatement">The <see cref="AssignmentStatement" /> instance that should be rewritten.</param>
        public override PromelaElement VisitAssignmentStatement(AssignmentStatement assignmentStatement)
        {
            Assert.ArgumentNotNull(assignmentStatement, () => assignmentStatement);

            var left = (VariableReferenceExpression)Visit(assignmentStatement.Left);
            var right = (Expression)Visit(assignmentStatement.Right);
            return assignmentStatement.Update(left, right);
        }

        /// <summary>
        ///     Rewrites an element of type <see cref="DeclarationStatement" />.
        /// </summary>
        /// <param name="declarationStatement">The <see cref="DeclarationStatement" /> instance that should be rewritten.</param>
        public override PromelaElement VisitDeclarationStatement(DeclarationStatement declarationStatement)
        {
            Assert.ArgumentNotNull(declarationStatement, () => declarationStatement);

            var type = declarationStatement.Type;
            var identifier = declarationStatement.Identifier;
            var arraySize = declarationStatement.ArraySize;
            var initialValue = (Expression)Visit(declarationStatement.InitialValue);
            return declarationStatement.Update(type, identifier, arraySize, initialValue);
        }
    }
}
